/*
Linode API

[Read the API documentation](https://techdocs.akamai.com/linode-api/reference/api).

API version: 4.189.2
Contact: support@linode.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DatabasesAPIService DatabasesAPI service
type DatabasesAPIService service

type ApiDeleteDatabaseMysqlInstanceBackupRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	backupId int32
}

func (r ApiDeleteDatabaseMysqlInstanceBackupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteDatabaseMysqlInstanceBackupExecute(r)
}

/*
DeleteDatabaseMysqlInstanceBackup Delete a managed MySQL database backup

__This operation is currently only available for customers who already have an active Managed Database.__

Delete a single backup for an accessible Managed MySQL Database.

Requires `read_write` access to the Database.

The Database must not be provisioning to perform this operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-backup-delete 123 456
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @param backupId The ID of the Managed MySQL Database backup.
 @return ApiDeleteDatabaseMysqlInstanceBackupRequest
*/
func (a *DatabasesAPIService) DeleteDatabaseMysqlInstanceBackup(ctx context.Context, apiVersion string, instanceId int32, backupId int32) ApiDeleteDatabaseMysqlInstanceBackupRequest {
	return ApiDeleteDatabaseMysqlInstanceBackupRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
		backupId: backupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) DeleteDatabaseMysqlInstanceBackupExecute(r ApiDeleteDatabaseMysqlInstanceBackupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.DeleteDatabaseMysqlInstanceBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}/backups/{backupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDatabasePostgreSqlInstanceBackupRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	backupId int32
}

func (r ApiDeleteDatabasePostgreSqlInstanceBackupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteDatabasePostgreSqlInstanceBackupExecute(r)
}

/*
DeleteDatabasePostgreSqlInstanceBackup Delete a managed PostgreSQL database backup

__This operation is currently only available for customers who already have an active Managed Database.__

Delete a single backup for an accessible Managed PostgreSQL Database.

Requires `read_write` access to the Database.

The Database must not be provisioning to perform this operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-backup-delete 123 456
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @param backupId The ID of the Managed PostgreSQL Database backup.
 @return ApiDeleteDatabasePostgreSqlInstanceBackupRequest
*/
func (a *DatabasesAPIService) DeleteDatabasePostgreSqlInstanceBackup(ctx context.Context, apiVersion string, instanceId int32, backupId int32) ApiDeleteDatabasePostgreSqlInstanceBackupRequest {
	return ApiDeleteDatabasePostgreSqlInstanceBackupRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
		backupId: backupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) DeleteDatabasePostgreSqlInstanceBackupExecute(r ApiDeleteDatabasePostgreSqlInstanceBackupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.DeleteDatabasePostgreSqlInstanceBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}/backups/{backupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDatabasesMysqlInstanceRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiDeleteDatabasesMysqlInstanceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteDatabasesMysqlInstanceExecute(r)
}

/*
DeleteDatabasesMysqlInstance Delete a managed MySQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Remove a Managed MySQL Database from your Account.

Requires `read_write` access to the Database.

The Database must have an `active`, `failed`, or `degraded` status to perform this operation.

Only unrestricted Users can access this operation, and have access regardless of the acting token's OAuth scopes.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-delete 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiDeleteDatabasesMysqlInstanceRequest
*/
func (a *DatabasesAPIService) DeleteDatabasesMysqlInstance(ctx context.Context, apiVersion string, instanceId int32) ApiDeleteDatabasesMysqlInstanceRequest {
	return ApiDeleteDatabasesMysqlInstanceRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) DeleteDatabasesMysqlInstanceExecute(r ApiDeleteDatabasesMysqlInstanceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.DeleteDatabasesMysqlInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDatabasesPostgreSqlInstanceRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiDeleteDatabasesPostgreSqlInstanceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteDatabasesPostgreSqlInstanceExecute(r)
}

/*
DeleteDatabasesPostgreSqlInstance Delete a managed PostgreSQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Remove a Managed PostgreSQL Database from your Account.

Requires `read_write` access to the Database.

The Database must have an `active`, `failed`, or `degraded` status to perform this operation.

Only unrestricted Users can access this operation, and have access regardless of the acting token's OAuth scopes.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-delete 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiDeleteDatabasesPostgreSqlInstanceRequest
*/
func (a *DatabasesAPIService) DeleteDatabasesPostgreSqlInstance(ctx context.Context, apiVersion string, instanceId int32) ApiDeleteDatabasesPostgreSqlInstanceRequest {
	return ApiDeleteDatabasesPostgreSqlInstanceRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) DeleteDatabasesPostgreSqlInstanceExecute(r ApiDeleteDatabasesPostgreSqlInstanceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.DeleteDatabasesPostgreSqlInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesEngineRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	engineId string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetDatabasesEngineRequest) Page(page int32) ApiGetDatabasesEngineRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetDatabasesEngineRequest) PageSize(pageSize int32) ApiGetDatabasesEngineRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDatabasesEngineRequest) Execute() (*GetDatabasesEngines200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.GetDatabasesEngineExecute(r)
}

/*
GetDatabasesEngine Get a managed database engine

__This operation is currently only available for customers who already have an active Managed Database.__

Display information for a single Managed Database engine type and version.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases engine-view
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param engineId The ID of the Managed Database engine.
 @return ApiGetDatabasesEngineRequest
*/
func (a *DatabasesAPIService) GetDatabasesEngine(ctx context.Context, apiVersion string, engineId string) ApiGetDatabasesEngineRequest {
	return ApiGetDatabasesEngineRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		engineId: engineId,
	}
}

// Execute executes the request
//  @return GetDatabasesEngines200ResponseAllOfDataInner
func (a *DatabasesAPIService) GetDatabasesEngineExecute(r ApiGetDatabasesEngineRequest) (*GetDatabasesEngines200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesEngines200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesEngine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/engines/{engineId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"engineId"+"}", url.PathEscape(parameterValueToString(r.engineId, "engineId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesEnginesRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetDatabasesEnginesRequest) Page(page int32) ApiGetDatabasesEnginesRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetDatabasesEnginesRequest) PageSize(pageSize int32) ApiGetDatabasesEnginesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDatabasesEnginesRequest) Execute() (*GetDatabasesEngines200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesEnginesExecute(r)
}

/*
GetDatabasesEngines List managed database engines

__This operation is currently only available for customers who already have an active Managed Database.__

Display all available Managed Database engine types and versions. Engine IDs are used when creating new Managed Databases.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases engines
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetDatabasesEnginesRequest
*/
func (a *DatabasesAPIService) GetDatabasesEngines(ctx context.Context, apiVersion string) ApiGetDatabasesEnginesRequest {
	return ApiGetDatabasesEnginesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetDatabasesEngines200Response
func (a *DatabasesAPIService) GetDatabasesEnginesExecute(r ApiGetDatabasesEnginesRequest) (*GetDatabasesEngines200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesEngines200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesEngines")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/engines"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesInstancesRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetDatabasesInstancesRequest) Page(page int32) ApiGetDatabasesInstancesRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetDatabasesInstancesRequest) PageSize(pageSize int32) ApiGetDatabasesInstancesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDatabasesInstancesRequest) Execute() (*GetDatabasesInstances200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesInstancesExecute(r)
}

/*
GetDatabasesInstances List managed databases

__This operation is currently only available for customers who already have an active Managed Database.__

Display all Managed Databases that are accessible by your User, regardless of engine type.

For more detailed information on a particular Database instance, make a request to its `instance_uri`.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetDatabasesInstancesRequest
*/
func (a *DatabasesAPIService) GetDatabasesInstances(ctx context.Context, apiVersion string) ApiGetDatabasesInstancesRequest {
	return ApiGetDatabasesInstancesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetDatabasesInstances200Response
func (a *DatabasesAPIService) GetDatabasesInstancesExecute(r ApiGetDatabasesInstancesRequest) (*GetDatabasesInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesMysqlInstanceRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiGetDatabasesMysqlInstanceRequest) Execute() (*GetDatabasesMysqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.GetDatabasesMysqlInstanceExecute(r)
}

/*
GetDatabasesMysqlInstance Get a managed MySQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Display information for a single, accessible Managed MySQL Database.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-view 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiGetDatabasesMysqlInstanceRequest
*/
func (a *DatabasesAPIService) GetDatabasesMysqlInstance(ctx context.Context, apiVersion string, instanceId int32) ApiGetDatabasesMysqlInstanceRequest {
	return ApiGetDatabasesMysqlInstanceRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstances200ResponseAllOfDataInner
func (a *DatabasesAPIService) GetDatabasesMysqlInstanceExecute(r ApiGetDatabasesMysqlInstanceRequest) (*GetDatabasesMysqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstances200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesMysqlInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesMysqlInstanceBackupRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	backupId int32
}

func (r ApiGetDatabasesMysqlInstanceBackupRequest) Execute() (*GetDatabasesMysqlInstanceBackups200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.GetDatabasesMysqlInstanceBackupExecute(r)
}

/*
GetDatabasesMysqlInstanceBackup Get a managed MySQL database backup

__This operation is currently only available for customers who already have an active Managed Database.__

Display information for a single backup for an accessible Managed MySQL Database.

The Database must not be provisioning to perform this operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-backup-view 123 456
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @param backupId The ID of the Managed MySQL Database backup.
 @return ApiGetDatabasesMysqlInstanceBackupRequest
*/
func (a *DatabasesAPIService) GetDatabasesMysqlInstanceBackup(ctx context.Context, apiVersion string, instanceId int32, backupId int32) ApiGetDatabasesMysqlInstanceBackupRequest {
	return ApiGetDatabasesMysqlInstanceBackupRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
		backupId: backupId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstanceBackups200ResponseAllOfDataInner
func (a *DatabasesAPIService) GetDatabasesMysqlInstanceBackupExecute(r ApiGetDatabasesMysqlInstanceBackupRequest) (*GetDatabasesMysqlInstanceBackups200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstanceBackups200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesMysqlInstanceBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}/backups/{backupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesMysqlInstanceBackupsRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetDatabasesMysqlInstanceBackupsRequest) Page(page int32) ApiGetDatabasesMysqlInstanceBackupsRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetDatabasesMysqlInstanceBackupsRequest) PageSize(pageSize int32) ApiGetDatabasesMysqlInstanceBackupsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDatabasesMysqlInstanceBackupsRequest) Execute() (*GetDatabasesMysqlInstanceBackups200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesMysqlInstanceBackupsExecute(r)
}

/*
GetDatabasesMysqlInstanceBackups List managed MySQL database backups

__This operation is currently only available for customers who already have an active Managed Database.__

Display all backups for an accessible Managed MySQL Database.

The Database must not be provisioning to perform this operation.

Database `auto` type backups are created every 24 hours at 0:00 UTC. Each `auto` backup is retained for 7 days.

Database `snapshot` type backups are created by accessing the [Create a managed MySQL database backup snapshot](https://techdocs.akamai.com/linode-api/reference/post-databases-mysql-instance-backup) operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-backups-list 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiGetDatabasesMysqlInstanceBackupsRequest
*/
func (a *DatabasesAPIService) GetDatabasesMysqlInstanceBackups(ctx context.Context, apiVersion string, instanceId int32) ApiGetDatabasesMysqlInstanceBackupsRequest {
	return ApiGetDatabasesMysqlInstanceBackupsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstanceBackups200Response
func (a *DatabasesAPIService) GetDatabasesMysqlInstanceBackupsExecute(r ApiGetDatabasesMysqlInstanceBackupsRequest) (*GetDatabasesMysqlInstanceBackups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstanceBackups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesMysqlInstanceBackups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesMysqlInstanceCredentialsRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiGetDatabasesMysqlInstanceCredentialsRequest) Execute() (*GetDatabasesMysqlInstanceCredentials200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesMysqlInstanceCredentialsExecute(r)
}

/*
GetDatabasesMysqlInstanceCredentials Get managed MySQL database credentials

__This operation is currently only available for customers who already have an active Managed Database.__

Display the root username and password for an accessible Managed MySQL Database.

The Database must have an `active` status to perform this operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-creds-view 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiGetDatabasesMysqlInstanceCredentialsRequest
*/
func (a *DatabasesAPIService) GetDatabasesMysqlInstanceCredentials(ctx context.Context, apiVersion string, instanceId int32) ApiGetDatabasesMysqlInstanceCredentialsRequest {
	return ApiGetDatabasesMysqlInstanceCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstanceCredentials200Response
func (a *DatabasesAPIService) GetDatabasesMysqlInstanceCredentialsExecute(r ApiGetDatabasesMysqlInstanceCredentialsRequest) (*GetDatabasesMysqlInstanceCredentials200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstanceCredentials200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesMysqlInstanceCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesMysqlInstanceSslRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiGetDatabasesMysqlInstanceSslRequest) Execute() (*GetDatabasesMysqlInstanceSsl200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesMysqlInstanceSslExecute(r)
}

/*
GetDatabasesMysqlInstanceSsl Get a managed MySQL database SSL certificate

__This operation is currently only available for customers who already have an active Managed Database.__

Display the SSL CA certificate for an accessible Managed MySQL Database.

The Database must have an `active` status to perform this operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-ssl-cert 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed MySQL Database.
 @return ApiGetDatabasesMysqlInstanceSslRequest
*/
func (a *DatabasesAPIService) GetDatabasesMysqlInstanceSsl(ctx context.Context, apiVersion string, instanceId int32) ApiGetDatabasesMysqlInstanceSslRequest {
	return ApiGetDatabasesMysqlInstanceSslRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstanceSsl200Response
func (a *DatabasesAPIService) GetDatabasesMysqlInstanceSslExecute(r ApiGetDatabasesMysqlInstanceSslRequest) (*GetDatabasesMysqlInstanceSsl200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstanceSsl200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesMysqlInstanceSsl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}/ssl"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesMysqlInstancesRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetDatabasesMysqlInstancesRequest) Page(page int32) ApiGetDatabasesMysqlInstancesRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetDatabasesMysqlInstancesRequest) PageSize(pageSize int32) ApiGetDatabasesMysqlInstancesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDatabasesMysqlInstancesRequest) Execute() (*GetDatabasesMysqlInstances200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesMysqlInstancesExecute(r)
}

/*
GetDatabasesMysqlInstances List managed MySQL databases

__This operation is currently only available for customers who already have an active Managed Database.__

Display all accessible Managed MySQL Databases.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetDatabasesMysqlInstancesRequest
*/
func (a *DatabasesAPIService) GetDatabasesMysqlInstances(ctx context.Context, apiVersion string) ApiGetDatabasesMysqlInstancesRequest {
	return ApiGetDatabasesMysqlInstancesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstances200Response
func (a *DatabasesAPIService) GetDatabasesMysqlInstancesExecute(r ApiGetDatabasesMysqlInstancesRequest) (*GetDatabasesMysqlInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesMysqlInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesPostgreSqlInstanceRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiGetDatabasesPostgreSqlInstanceRequest) Execute() (*GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.GetDatabasesPostgreSqlInstanceExecute(r)
}

/*
GetDatabasesPostgreSqlInstance Get a managed PostgreSQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Display information for a single, accessible Managed PostgreSQL Database.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-view 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiGetDatabasesPostgreSqlInstanceRequest
*/
func (a *DatabasesAPIService) GetDatabasesPostgreSqlInstance(ctx context.Context, apiVersion string, instanceId int32) ApiGetDatabasesPostgreSqlInstanceRequest {
	return ApiGetDatabasesPostgreSqlInstanceRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner
func (a *DatabasesAPIService) GetDatabasesPostgreSqlInstanceExecute(r ApiGetDatabasesPostgreSqlInstanceRequest) (*GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesPostgreSqlInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesPostgreSqlInstanceBackupsRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetDatabasesPostgreSqlInstanceBackupsRequest) Page(page int32) ApiGetDatabasesPostgreSqlInstanceBackupsRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetDatabasesPostgreSqlInstanceBackupsRequest) PageSize(pageSize int32) ApiGetDatabasesPostgreSqlInstanceBackupsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDatabasesPostgreSqlInstanceBackupsRequest) Execute() (*GetDatabasesMysqlInstanceBackups200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesPostgreSqlInstanceBackupsExecute(r)
}

/*
GetDatabasesPostgreSqlInstanceBackups List managed PostgreSQL database backups

__This operation is currently only available for customers who already have an active Managed Database.__

Display all backups for an accessible Managed PostgreSQL Database.

The Database must not be provisioning to perform this operation.

Database `auto` type backups are created every 24 hours at 0:00 UTC. Each `auto` backup is retained for 7 days.

Database `snapshot` type backups are created by accessing the [Create a managed PostgreSQL database backup snapshot](https://techdocs.akamai.com/linode-api/reference/post-databases-postgre-sql-instance-backup) operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-backups-list 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiGetDatabasesPostgreSqlInstanceBackupsRequest
*/
func (a *DatabasesAPIService) GetDatabasesPostgreSqlInstanceBackups(ctx context.Context, apiVersion string, instanceId int32) ApiGetDatabasesPostgreSqlInstanceBackupsRequest {
	return ApiGetDatabasesPostgreSqlInstanceBackupsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstanceBackups200Response
func (a *DatabasesAPIService) GetDatabasesPostgreSqlInstanceBackupsExecute(r ApiGetDatabasesPostgreSqlInstanceBackupsRequest) (*GetDatabasesMysqlInstanceBackups200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstanceBackups200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesPostgreSqlInstanceBackups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesPostgreSqlInstanceCredentialsRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiGetDatabasesPostgreSqlInstanceCredentialsRequest) Execute() (*GetDatabasesMysqlInstanceCredentials200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesPostgreSqlInstanceCredentialsExecute(r)
}

/*
GetDatabasesPostgreSqlInstanceCredentials Get managed PostgreSQL database credentials

__This operation is currently only available for customers who already have an active Managed Database.__

Display the root username and password for an accessible Managed PostgreSQL Database.

The Database must have an `active` status to perform this operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-creds-view 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiGetDatabasesPostgreSqlInstanceCredentialsRequest
*/
func (a *DatabasesAPIService) GetDatabasesPostgreSqlInstanceCredentials(ctx context.Context, apiVersion string, instanceId int32) ApiGetDatabasesPostgreSqlInstanceCredentialsRequest {
	return ApiGetDatabasesPostgreSqlInstanceCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstanceCredentials200Response
func (a *DatabasesAPIService) GetDatabasesPostgreSqlInstanceCredentialsExecute(r ApiGetDatabasesPostgreSqlInstanceCredentialsRequest) (*GetDatabasesMysqlInstanceCredentials200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstanceCredentials200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesPostgreSqlInstanceCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}/credentials"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesPostgreSqlInstancesRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetDatabasesPostgreSqlInstancesRequest) Page(page int32) ApiGetDatabasesPostgreSqlInstancesRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetDatabasesPostgreSqlInstancesRequest) PageSize(pageSize int32) ApiGetDatabasesPostgreSqlInstancesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDatabasesPostgreSqlInstancesRequest) Execute() (*GetDatabasesPostgreSqlInstances200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesPostgreSqlInstancesExecute(r)
}

/*
GetDatabasesPostgreSqlInstances List managed PostgreSQL databases

__This operation is currently only available for customers who already have an active Managed Database.__

Display all accessible Managed PostgreSQL Databases.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetDatabasesPostgreSqlInstancesRequest
*/
func (a *DatabasesAPIService) GetDatabasesPostgreSqlInstances(ctx context.Context, apiVersion string) ApiGetDatabasesPostgreSqlInstancesRequest {
	return ApiGetDatabasesPostgreSqlInstancesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetDatabasesPostgreSqlInstances200Response
func (a *DatabasesAPIService) GetDatabasesPostgreSqlInstancesExecute(r ApiGetDatabasesPostgreSqlInstancesRequest) (*GetDatabasesPostgreSqlInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesPostgreSqlInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesPostgreSqlInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesPostgresqlInstanceBackupRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	backupId int32
}

func (r ApiGetDatabasesPostgresqlInstanceBackupRequest) Execute() (*GetDatabasesMysqlInstanceBackups200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.GetDatabasesPostgresqlInstanceBackupExecute(r)
}

/*
GetDatabasesPostgresqlInstanceBackup Get a managed PostgreSQL database backup

__This operation is currently only available for customers who already have an active Managed Database.__

Display information for a single backup for an accessible Managed PostgreSQL Database.

The Database must not be provisioning to perform this operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-backup-view 123 456
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @param backupId The ID of the Managed PostgreSQL Database backup.
 @return ApiGetDatabasesPostgresqlInstanceBackupRequest
*/
func (a *DatabasesAPIService) GetDatabasesPostgresqlInstanceBackup(ctx context.Context, apiVersion string, instanceId int32, backupId int32) ApiGetDatabasesPostgresqlInstanceBackupRequest {
	return ApiGetDatabasesPostgresqlInstanceBackupRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
		backupId: backupId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstanceBackups200ResponseAllOfDataInner
func (a *DatabasesAPIService) GetDatabasesPostgresqlInstanceBackupExecute(r ApiGetDatabasesPostgresqlInstanceBackupRequest) (*GetDatabasesMysqlInstanceBackups200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstanceBackups200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesPostgresqlInstanceBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}/backups/{backupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesPostgresqlInstanceSslRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiGetDatabasesPostgresqlInstanceSslRequest) Execute() (*GetDatabasesMysqlInstanceSsl200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesPostgresqlInstanceSslExecute(r)
}

/*
GetDatabasesPostgresqlInstanceSsl Get a managed PostgreSQL database SSL certificate

__This operation is currently only available for customers who already have an active Managed Database.__

Display the SSL CA certificate for an accessible Managed PostgreSQL Database.

The Database must have an `active` status to perform this operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-ssl-cert 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiGetDatabasesPostgresqlInstanceSslRequest
*/
func (a *DatabasesAPIService) GetDatabasesPostgresqlInstanceSsl(ctx context.Context, apiVersion string, instanceId int32) ApiGetDatabasesPostgresqlInstanceSslRequest {
	return ApiGetDatabasesPostgresqlInstanceSslRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstanceSsl200Response
func (a *DatabasesAPIService) GetDatabasesPostgresqlInstanceSslExecute(r ApiGetDatabasesPostgresqlInstanceSslRequest) (*GetDatabasesMysqlInstanceSsl200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstanceSsl200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesPostgresqlInstanceSsl")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}/ssl"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesTypeRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	typeId string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetDatabasesTypeRequest) Page(page int32) ApiGetDatabasesTypeRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetDatabasesTypeRequest) PageSize(pageSize int32) ApiGetDatabasesTypeRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDatabasesTypeRequest) Execute() (*GetDatabasesTypes200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.GetDatabasesTypeExecute(r)
}

/*
GetDatabasesType Get a managed database type

__This operation is currently only available for customers who already have an active Managed Database.__

Display the details of a single Managed Database type. The type and number of nodes determine the resources and price of a Managed Database instance.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases type-view
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param typeId The ID of the Managed Database type.
 @return ApiGetDatabasesTypeRequest
*/
func (a *DatabasesAPIService) GetDatabasesType(ctx context.Context, apiVersion string, typeId string) ApiGetDatabasesTypeRequest {
	return ApiGetDatabasesTypeRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		typeId: typeId,
	}
}

// Execute executes the request
//  @return GetDatabasesTypes200ResponseAllOfDataInner
func (a *DatabasesAPIService) GetDatabasesTypeExecute(r ApiGetDatabasesTypeRequest) (*GetDatabasesTypes200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesTypes200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/types/{typeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"typeId"+"}", url.PathEscape(parameterValueToString(r.typeId, "typeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabasesTypesRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetDatabasesTypesRequest) Page(page int32) ApiGetDatabasesTypesRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetDatabasesTypesRequest) PageSize(pageSize int32) ApiGetDatabasesTypesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetDatabasesTypesRequest) Execute() (*GetDatabasesTypes200Response, *http.Response, error) {
	return r.ApiService.GetDatabasesTypesExecute(r)
}

/*
GetDatabasesTypes List managed database types

__This operation is currently only available for customers who already have an active Managed Database.__

Display all Managed Database node types. The type and number of nodes determine the resources and price of a Managed Database instance.

Each Managed Database can have one node type. In the case of a high availability Database, all nodes are provisioned according to the chosen type.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases types
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetDatabasesTypesRequest
*/
func (a *DatabasesAPIService) GetDatabasesTypes(ctx context.Context, apiVersion string) ApiGetDatabasesTypesRequest {
	return ApiGetDatabasesTypesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetDatabasesTypes200Response
func (a *DatabasesAPIService) GetDatabasesTypesExecute(r ApiGetDatabasesTypesRequest) (*GetDatabasesTypes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesTypes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.GetDatabasesTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/types"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesMysqlInstanceBackupRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	postDatabasesMysqlInstanceBackupRequest *PostDatabasesMysqlInstanceBackupRequest
}

// Information about the snapshot backup to create.
func (r ApiPostDatabasesMysqlInstanceBackupRequest) PostDatabasesMysqlInstanceBackupRequest(postDatabasesMysqlInstanceBackupRequest PostDatabasesMysqlInstanceBackupRequest) ApiPostDatabasesMysqlInstanceBackupRequest {
	r.postDatabasesMysqlInstanceBackupRequest = &postDatabasesMysqlInstanceBackupRequest
	return r
}

func (r ApiPostDatabasesMysqlInstanceBackupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostDatabasesMysqlInstanceBackupExecute(r)
}

/*
PostDatabasesMysqlInstanceBackup Create a managed MySQL database backup snapshot

__This operation is currently only available for customers who already have an active Managed Database.__

Creates a snapshot backup of a Managed MySQL Database.

Requires `read_write` access to the Database.

Up to 3 snapshot backups for each Database can be stored at a time. If 3 snapshots have been created for a Database, one must be deleted before another can be made.

Backups generated by this operation have the type `snapshot`. Snapshot backups may take several minutes to complete, after which they will be accessible to view or restore.

The Database must have an `active` status to perform this operation. If another backup is in progress, it must complete before a new backup can be initiated.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-backup-snapshot 123 \
  --label snapshot1 \
  --target primary
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiPostDatabasesMysqlInstanceBackupRequest
*/
func (a *DatabasesAPIService) PostDatabasesMysqlInstanceBackup(ctx context.Context, apiVersion string, instanceId int32) ApiPostDatabasesMysqlInstanceBackupRequest {
	return ApiPostDatabasesMysqlInstanceBackupRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) PostDatabasesMysqlInstanceBackupExecute(r ApiPostDatabasesMysqlInstanceBackupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesMysqlInstanceBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postDatabasesMysqlInstanceBackupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesMysqlInstanceBackupRestoreRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	backupId int32
}

func (r ApiPostDatabasesMysqlInstanceBackupRestoreRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostDatabasesMysqlInstanceBackupRestoreExecute(r)
}

/*
PostDatabasesMysqlInstanceBackupRestore Restore a managed MySQL database backup

__This operation is currently only available for customers who already have an active Managed Database.__

Restore a backup to a Managed MySQL Database on your Account.

Requires `read_write` access to the Database.

The Database must have an `active`, `degraded`, or `failed` status to perform this operation.

__Note__. Restoring from a backup will erase all existing data on the database instance and replace it with backup data.

__Note__. Currently, restoring a backup after resetting Managed Database credentials results in a failed cluster. Please contact Customer Support if this occurs.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-backup-restore 123 456
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed MySQL Database.
 @param backupId The ID of the Managed MySQL Database backup.
 @return ApiPostDatabasesMysqlInstanceBackupRestoreRequest
*/
func (a *DatabasesAPIService) PostDatabasesMysqlInstanceBackupRestore(ctx context.Context, apiVersion string, instanceId int32, backupId int32) ApiPostDatabasesMysqlInstanceBackupRestoreRequest {
	return ApiPostDatabasesMysqlInstanceBackupRestoreRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
		backupId: backupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) PostDatabasesMysqlInstanceBackupRestoreExecute(r ApiPostDatabasesMysqlInstanceBackupRestoreRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesMysqlInstanceBackupRestore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}/backups/{backupId}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesMysqlInstanceCredentialsResetRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiPostDatabasesMysqlInstanceCredentialsResetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostDatabasesMysqlInstanceCredentialsResetExecute(r)
}

/*
PostDatabasesMysqlInstanceCredentialsReset Reset managed MySQL database credentials

__This operation is currently only available for customers who already have an active Managed Database.__

Reset the root password for a Managed MySQL Database.

Requires `read_write` access to the Database.

A new root password is randomly generated and accessible with the [Get managed MySQL database credentials](https://techdocs.akamai.com/linode-api/reference/get-databases-mysql-instance-credentials) operation.

Only unrestricted Users can access this operation, and have access regardless of the acting token's OAuth scopes.

__Note__. It may take several seconds for credentials to reset.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-creds-reset 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed MySQL Database.
 @return ApiPostDatabasesMysqlInstanceCredentialsResetRequest
*/
func (a *DatabasesAPIService) PostDatabasesMysqlInstanceCredentialsReset(ctx context.Context, apiVersion string, instanceId int32) ApiPostDatabasesMysqlInstanceCredentialsResetRequest {
	return ApiPostDatabasesMysqlInstanceCredentialsResetRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) PostDatabasesMysqlInstanceCredentialsResetExecute(r ApiPostDatabasesMysqlInstanceCredentialsResetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesMysqlInstanceCredentialsReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}/credentials/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesMysqlInstancePatchRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiPostDatabasesMysqlInstancePatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostDatabasesMysqlInstancePatchExecute(r)
}

/*
PostDatabasesMysqlInstancePatch Patch a managed MySQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Apply security patches and updates to the underlying operating system of the Managed MySQL Database. This function runs during regular maintenance windows, which are configurable with the [Update a managed MySQL database](https://techdocs.akamai.com/linode-api/reference/put-databases-mysql-instance) operation.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this operation.

__Note__

- If your database cluster is configured with a single node, you will experience downtime during this maintenance. Consider upgrading to a high availability plan to avoid any downtime due to maintenance.

- __The database software is not updated automatically.__ To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then [migrate your databases](https://www.linode.com/docs/products/databases/managed-databases/guides/migrate-mysql/) from the original Managed Database cluster to the new one.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-patch 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiPostDatabasesMysqlInstancePatchRequest
*/
func (a *DatabasesAPIService) PostDatabasesMysqlInstancePatch(ctx context.Context, apiVersion string, instanceId int32) ApiPostDatabasesMysqlInstancePatchRequest {
	return ApiPostDatabasesMysqlInstancePatchRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) PostDatabasesMysqlInstancePatchExecute(r ApiPostDatabasesMysqlInstancePatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesMysqlInstancePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}/patch"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesMysqlInstancesRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	postDatabasesMysqlInstancesRequest *PostDatabasesMysqlInstancesRequest
}

// Information about the Managed MySQL Database you are creating.
func (r ApiPostDatabasesMysqlInstancesRequest) PostDatabasesMysqlInstancesRequest(postDatabasesMysqlInstancesRequest PostDatabasesMysqlInstancesRequest) ApiPostDatabasesMysqlInstancesRequest {
	r.postDatabasesMysqlInstancesRequest = &postDatabasesMysqlInstancesRequest
	return r
}

func (r ApiPostDatabasesMysqlInstancesRequest) Execute() (*GetDatabasesMysqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.PostDatabasesMysqlInstancesExecute(r)
}

/*
PostDatabasesMysqlInstances Create a managed MySQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Provision a Managed MySQL Database.

Restricted Users must have the `add_databases` grant to use this operation.

New instances can take approximately 15 to 30 minutes to provision.

The `allow_list` is used to control access to the Managed Database.

- IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.

- If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.

- Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.

All Managed Databases include automatic, daily backups. Up to seven backups are automatically stored for each Managed Database, providing restore points for each day of the past week.

All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed MySQL Database during configurable maintenance windows.

- If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.

- __The database software is not updated automatically.__ To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then [migrate your databases](https://www.linode.com/docs/products/databases/managed-databases/guides/migrate-mysql/) from the original Managed Database cluster to the new one.

- To modify update the maintenance window for a Database, run the [Update a managed MySQL database](https://techdocs.akamai.com/linode-api/reference/put-databases-mysql-instance) operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-create \
  --label example-db1 \
  --region us-east \
  --type g6-dedicated-2 \
  --cluster_size 3 \
  --engine mysql/8.0.26 \
  --encrypted false \
  --ssl_connection false \
  --replication_type semi_synch \
  --allow_list 203.0.113.1 \
  --allow_list 192.0.1.0/24
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostDatabasesMysqlInstancesRequest
*/
func (a *DatabasesAPIService) PostDatabasesMysqlInstances(ctx context.Context, apiVersion string) ApiPostDatabasesMysqlInstancesRequest {
	return ApiPostDatabasesMysqlInstancesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstances200ResponseAllOfDataInner
func (a *DatabasesAPIService) PostDatabasesMysqlInstancesExecute(r ApiPostDatabasesMysqlInstancesRequest) (*GetDatabasesMysqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstances200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesMysqlInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postDatabasesMysqlInstancesRequest == nil {
		return localVarReturnValue, nil, reportError("postDatabasesMysqlInstancesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postDatabasesMysqlInstancesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesPostgreSqlInstanceBackupRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	postDatabasesMysqlInstanceBackupRequest *PostDatabasesMysqlInstanceBackupRequest
}

// Information about the snapshot backup to create.
func (r ApiPostDatabasesPostgreSqlInstanceBackupRequest) PostDatabasesMysqlInstanceBackupRequest(postDatabasesMysqlInstanceBackupRequest PostDatabasesMysqlInstanceBackupRequest) ApiPostDatabasesPostgreSqlInstanceBackupRequest {
	r.postDatabasesMysqlInstanceBackupRequest = &postDatabasesMysqlInstanceBackupRequest
	return r
}

func (r ApiPostDatabasesPostgreSqlInstanceBackupRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostDatabasesPostgreSqlInstanceBackupExecute(r)
}

/*
PostDatabasesPostgreSqlInstanceBackup Create a managed PostgreSQL database backup snapshot

__This operation is currently only available for customers who already have an active Managed Database.__

Creates a snapshot backup of a Managed PostgreSQL Database.

Requires `read_write` access to the Database.

Up to 3 snapshot backups for each Database can be stored at a time. If 3 snapshots have been created for a Database, one must be deleted before another can be made.

Backups generated by this operation have the type `snapshot`. Snapshot backups may take several minutes to complete, after which they will be accessible to view or restore.

The Database must have an `active` status to perform this operation. If another backup is in progress, it must complete before a new backup can be initiated.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-backup-snapshot 123 \
  --label snapshot1 \
  --target primary
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiPostDatabasesPostgreSqlInstanceBackupRequest
*/
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstanceBackup(ctx context.Context, apiVersion string, instanceId int32) ApiPostDatabasesPostgreSqlInstanceBackupRequest {
	return ApiPostDatabasesPostgreSqlInstanceBackupRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstanceBackupExecute(r ApiPostDatabasesPostgreSqlInstanceBackupRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesPostgreSqlInstanceBackup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}/backups"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postDatabasesMysqlInstanceBackupRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesPostgreSqlInstanceBackupRestoreRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	backupId int32
}

func (r ApiPostDatabasesPostgreSqlInstanceBackupRestoreRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostDatabasesPostgreSqlInstanceBackupRestoreExecute(r)
}

/*
PostDatabasesPostgreSqlInstanceBackupRestore Restore a managed PostgreSQL database backup

__This operation is currently only available for customers who already have an active Managed Database.__

Restore a backup to a Managed PostgreSQL Database on your Account.

Requires `read_write` access to the Database.

The Database must have an `active`, `degraded`, or `failed` status to perform this operation.

__Note__. Restoring from a backup will erase all existing data on the database instance and replace it with backup data.

__Note__. Currently, restoring a backup after resetting Managed Database credentials results in a failed cluster. Please contact Customer Support if this occurs.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-backup-restore 123 456
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @param backupId The ID of the Managed PostgreSQL Database backup.
 @return ApiPostDatabasesPostgreSqlInstanceBackupRestoreRequest
*/
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstanceBackupRestore(ctx context.Context, apiVersion string, instanceId int32, backupId int32) ApiPostDatabasesPostgreSqlInstanceBackupRestoreRequest {
	return ApiPostDatabasesPostgreSqlInstanceBackupRestoreRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
		backupId: backupId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstanceBackupRestoreExecute(r ApiPostDatabasesPostgreSqlInstanceBackupRestoreRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesPostgreSqlInstanceBackupRestore")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}/backups/{backupId}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"backupId"+"}", url.PathEscape(parameterValueToString(r.backupId, "backupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesPostgreSqlInstanceCredentialsResetRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiPostDatabasesPostgreSqlInstanceCredentialsResetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostDatabasesPostgreSqlInstanceCredentialsResetExecute(r)
}

/*
PostDatabasesPostgreSqlInstanceCredentialsReset Reset managed PostgreSQL database credentials

__This operation is currently only available for customers who already have an active Managed Database.__

Reset the root password for a Managed PostgreSQL Database.

Requires `read_write` access to the Database.

A new root password is randomly generated and accessible with the [Get managed PostgreSQL database credentials](https://techdocs.akamai.com/linode-api/reference/get-databases-postgre-sql-instance-credentials) operation.

Only unrestricted Users can access this operation, and have access regardless of the acting token's OAuth scopes.

__Note__. It may take several seconds for credentials to reset.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-creds-reset 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiPostDatabasesPostgreSqlInstanceCredentialsResetRequest
*/
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstanceCredentialsReset(ctx context.Context, apiVersion string, instanceId int32) ApiPostDatabasesPostgreSqlInstanceCredentialsResetRequest {
	return ApiPostDatabasesPostgreSqlInstanceCredentialsResetRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstanceCredentialsResetExecute(r ApiPostDatabasesPostgreSqlInstanceCredentialsResetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesPostgreSqlInstanceCredentialsReset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}/credentials/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesPostgreSqlInstancePatchRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
}

func (r ApiPostDatabasesPostgreSqlInstancePatchRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostDatabasesPostgreSqlInstancePatchExecute(r)
}

/*
PostDatabasesPostgreSqlInstancePatch Patch a managed PostgreSQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Apply security patches and updates to the underlying operating system of the Managed PostgreSQL Database. This function runs during regular maintenance windows, which are configurable with the [Update a managed PostgreSQL database](https://techdocs.akamai.com/linode-api/reference/put-databases-postgre-sql-instance) operation.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this operation.

__Note__

- If your database cluster is configured with a single node, you will experience downtime during this maintenance. Consider upgrading to a high availability plan to avoid any downtime due to maintenance.

- __The database software is not updated automatically.__ To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-patch 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiPostDatabasesPostgreSqlInstancePatchRequest
*/
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstancePatch(ctx context.Context, apiVersion string, instanceId int32) ApiPostDatabasesPostgreSqlInstancePatchRequest {
	return ApiPostDatabasesPostgreSqlInstancePatchRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstancePatchExecute(r ApiPostDatabasesPostgreSqlInstancePatchRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesPostgreSqlInstancePatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}/patch"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostDatabasesPostgreSqlInstancesRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	postDatabasesPostgreSqlInstancesRequest *PostDatabasesPostgreSqlInstancesRequest
}

// Information about the Managed PostgreSQL Database you are creating.
func (r ApiPostDatabasesPostgreSqlInstancesRequest) PostDatabasesPostgreSqlInstancesRequest(postDatabasesPostgreSqlInstancesRequest PostDatabasesPostgreSqlInstancesRequest) ApiPostDatabasesPostgreSqlInstancesRequest {
	r.postDatabasesPostgreSqlInstancesRequest = &postDatabasesPostgreSqlInstancesRequest
	return r
}

func (r ApiPostDatabasesPostgreSqlInstancesRequest) Execute() (*GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.PostDatabasesPostgreSqlInstancesExecute(r)
}

/*
PostDatabasesPostgreSqlInstances Create a managed PostgreSQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Provision a Managed PostgreSQL Database.

Restricted Users must have the `add_databases` grant to use this operation.

New instances can take approximately 15 to 30 minutes to provision.

The `allow_list` is used to control access to the Managed Database.

- IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.

- If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.

- Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.

All Managed Databases include automatic, daily backups. Up to seven backups are automatically stored for each Managed Database, providing restore points for each day of the past week.

All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed PostgreSQL Database during configurable maintenance windows.

- If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.

- __The database software is not updated automatically.__ To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.

- To modify update the maintenance window for a Database, run the [Update a managed PostgreSQL database](https://techdocs.akamai.com/linode-api/reference/put-databases-postgre-sql-instance) operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-create \
  --label example-db \
  --region us-east \
  --type g6-dedicated-2 \
  --cluster_size 3 \
  --engine postgresql/13.2 \
  --encrypted false \
  --ssl_connection false \
  --replication_type asynch \
  --replication_commit_type local \
  --allow_list 203.0.113.1 \
  --allow_list 192.0.1.0/24
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostDatabasesPostgreSqlInstancesRequest
*/
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstances(ctx context.Context, apiVersion string) ApiPostDatabasesPostgreSqlInstancesRequest {
	return ApiPostDatabasesPostgreSqlInstancesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner
func (a *DatabasesAPIService) PostDatabasesPostgreSqlInstancesExecute(r ApiPostDatabasesPostgreSqlInstancesRequest) (*GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PostDatabasesPostgreSqlInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postDatabasesPostgreSqlInstancesRequest == nil {
		return localVarReturnValue, nil, reportError("postDatabasesPostgreSqlInstancesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postDatabasesPostgreSqlInstancesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDatabasesMysqlInstanceRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	putDatabasesMysqlInstanceRequest *PutDatabasesMysqlInstanceRequest
}

// Updated information for the Managed MySQL Database.
func (r ApiPutDatabasesMysqlInstanceRequest) PutDatabasesMysqlInstanceRequest(putDatabasesMysqlInstanceRequest PutDatabasesMysqlInstanceRequest) ApiPutDatabasesMysqlInstanceRequest {
	r.putDatabasesMysqlInstanceRequest = &putDatabasesMysqlInstanceRequest
	return r
}

func (r ApiPutDatabasesMysqlInstanceRequest) Execute() (*GetDatabasesMysqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.PutDatabasesMysqlInstanceExecute(r)
}

/*
PutDatabasesMysqlInstance Update a managed MySQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Update a Managed MySQL Database.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this operation.

Updating addresses in the `allow_list` overwrites any existing addresses.

- IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.

- If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.

- Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.

- __Note__. Updates to the `allow_list` may take a short period of time to complete, making this operation inappropriate for rapid successive updates to this property.

All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed MySQL Database. The maintenance window for these updates is configured with the Managed Database's `updates` property.

- If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.

- __The database software is not updated automatically.__ To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then [migrate your databases](https://www.linode.com/docs/products/databases/managed-databases/guides/migrate-mysql/) from the original Managed Database cluster to the new one.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases mysql-update 123 \
  --label example-db \
  --allow_list 203.0.113.1 \
  --allow_list 192.0.1.0/24 \
  --type g6-standard-1 \
  --updates.frequency monthly \
  --updates.duration 3 \
  --updates.hour_of_day 12 \
  --updates.day_of_week 4 \
  --updates.week_of_month 3
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiPutDatabasesMysqlInstanceRequest
*/
func (a *DatabasesAPIService) PutDatabasesMysqlInstance(ctx context.Context, apiVersion string, instanceId int32) ApiPutDatabasesMysqlInstanceRequest {
	return ApiPutDatabasesMysqlInstanceRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesMysqlInstances200ResponseAllOfDataInner
func (a *DatabasesAPIService) PutDatabasesMysqlInstanceExecute(r ApiPutDatabasesMysqlInstanceRequest) (*GetDatabasesMysqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesMysqlInstances200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PutDatabasesMysqlInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/mysql/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.putDatabasesMysqlInstanceRequest == nil {
		return localVarReturnValue, nil, reportError("putDatabasesMysqlInstanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putDatabasesMysqlInstanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutDatabasesPostgreSqlInstanceRequest struct {
	ctx context.Context
	ApiService *DatabasesAPIService
	apiVersion string
	instanceId int32
	putDatabasesPostgreSqlInstanceRequest *PutDatabasesPostgreSqlInstanceRequest
}

// Updated information for the Managed PostgreSQL Database.
func (r ApiPutDatabasesPostgreSqlInstanceRequest) PutDatabasesPostgreSqlInstanceRequest(putDatabasesPostgreSqlInstanceRequest PutDatabasesPostgreSqlInstanceRequest) ApiPutDatabasesPostgreSqlInstanceRequest {
	r.putDatabasesPostgreSqlInstanceRequest = &putDatabasesPostgreSqlInstanceRequest
	return r
}

func (r ApiPutDatabasesPostgreSqlInstanceRequest) Execute() (*GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	return r.ApiService.PutDatabasesPostgreSqlInstanceExecute(r)
}

/*
PutDatabasesPostgreSqlInstance Update a managed PostgreSQL database

__This operation is currently only available for customers who already have an active Managed Database.__

Update a Managed PostgreSQL Database.

Requires `read_write` access to the Database.

The Database must have an `active` status to perform this operation.

Updating addresses in the `allow_list` overwrites any existing addresses.

- IP addresses and ranges in this list can access the Managed Database. All other sources are blocked.

- If `0.0.0.0/0` is a value in this list, then all IP addresses can access the Managed Database.

- Entering an empty array (`[]`) blocks all connections (both public and private) to the Managed Database.

- __Note__. Updates to the `allow_list` may take a short period of time to complete, making this operation inappropriate for rapid successive updates to this property.

All Managed Databases include automatic patch updates, which apply security patches and updates to the underlying operating system of the Managed PostgreSQL Database. The maintenance window for these updates is configured with the Managed Database's `updates` property.

- If your database cluster is configured with a single node, you will experience downtime during this maintenance window when any updates occur. It's recommended that you adjust this window to match a time that will be the least disruptive for your application and users. You may also want to consider upgrading to a high availability plan to avoid any downtime due to maintenance.

- __The database software is not updated automatically.__ To upgrade to a new database engine version, consider deploying a new Managed Database with your preferred version. You can then migrate your databases from the original Managed Database cluster to the new one.


<<LB>>

---


- __CLI__.

    ```
    linode-cli databases postgresql-update 123 \
  --label example-db \
  --allow_list 203.0.113.1 \
  --allow_list 192.0.1.0/24 \
  --type g6-standard-1 \
  --updates.frequency monthly \
  --updates.duration 3 \
  --updates.hour_of_day 12 \
  --updates.day_of_week 4 \
  --updates.week_of_month 3
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    databases:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param instanceId The ID of the Managed PostgreSQL Database.
 @return ApiPutDatabasesPostgreSqlInstanceRequest
*/
func (a *DatabasesAPIService) PutDatabasesPostgreSqlInstance(ctx context.Context, apiVersion string, instanceId int32) ApiPutDatabasesPostgreSqlInstanceRequest {
	return ApiPutDatabasesPostgreSqlInstanceRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		instanceId: instanceId,
	}
}

// Execute executes the request
//  @return GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner
func (a *DatabasesAPIService) PutDatabasesPostgreSqlInstanceExecute(r ApiPutDatabasesPostgreSqlInstanceRequest) (*GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDatabasesPostgreSqlInstances200ResponseAllOfDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabasesAPIService.PutDatabasesPostgreSqlInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/databases/postgresql/instances/{instanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"instanceId"+"}", url.PathEscape(parameterValueToString(r.instanceId, "instanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.putDatabasesPostgreSqlInstanceRequest == nil {
		return localVarReturnValue, nil, reportError("putDatabasesPostgreSqlInstanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putDatabasesPostgreSqlInstanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
