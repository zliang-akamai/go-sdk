/*
Linode API

[Read the API documentation](https://techdocs.akamai.com/linode-api/reference/api).

API version: 4.189.2
Contact: support@linode.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// NodeBalancersAPIService NodeBalancersAPI service
type NodeBalancersAPIService service

type ApiDeleteNodeBalancerRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
}

func (r ApiDeleteNodeBalancerRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteNodeBalancerExecute(r)
}

/*
DeleteNodeBalancer Delete a NodeBalancer

Deletes a NodeBalancer.

__This is a destructive action and cannot be undone.__

Deleting a NodeBalancer will also delete all associated Configs and Nodes, although the backend servers represented by the Nodes will not be changed or removed. Deleting a NodeBalancer will cause you to lose access to the IP Addresses assigned to this NodeBalancer.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers delete 12345
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @return ApiDeleteNodeBalancerRequest
*/
func (a *NodeBalancersAPIService) DeleteNodeBalancer(ctx context.Context, apiVersion string, nodeBalancerId int32) ApiDeleteNodeBalancerRequest {
	return ApiDeleteNodeBalancerRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *NodeBalancersAPIService) DeleteNodeBalancerExecute(r ApiDeleteNodeBalancerRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.DeleteNodeBalancer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNodeBalancerConfigRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	configId int32
}

func (r ApiDeleteNodeBalancerConfigRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteNodeBalancerConfigExecute(r)
}

/*
DeleteNodeBalancerConfig Delete a config

Deletes the Config for a port of this NodeBalancer.

__This cannot be undone.__

Once completed, this NodeBalancer will no longer respond to requests on the given port. This also deletes all associated NodeBalancerNodes, but the Linodes they were routing traffic to will be unchanged and will not be removed.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers config-delete \
  12345 4567
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @param configId The ID of the Config to access.
 @return ApiDeleteNodeBalancerConfigRequest
*/
func (a *NodeBalancersAPIService) DeleteNodeBalancerConfig(ctx context.Context, apiVersion string, nodeBalancerId int32, configId int32) ApiDeleteNodeBalancerConfigRequest {
	return ApiDeleteNodeBalancerConfigRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
		configId: configId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *NodeBalancersAPIService) DeleteNodeBalancerConfigExecute(r ApiDeleteNodeBalancerConfigRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.DeleteNodeBalancerConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", url.PathEscape(parameterValueToString(r.configId, "configId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNodeBalancerConfigNodeRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	configId int32
	nodeId string
}

func (r ApiDeleteNodeBalancerConfigNodeRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteNodeBalancerConfigNodeExecute(r)
}

/*
DeleteNodeBalancerConfigNode Delete a NodeBalancer's node

Deletes a Node from this Config. This backend will no longer receive traffic for the configured port of this NodeBalancer.

This does not change or remove the Linode whose address was used in the creation of this Node.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers node-delete \
  12345 4567 54321
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @param configId The ID of the Config to access.
 @param nodeId The ID of the Node to access.
 @return ApiDeleteNodeBalancerConfigNodeRequest
*/
func (a *NodeBalancersAPIService) DeleteNodeBalancerConfigNode(ctx context.Context, apiVersion string, nodeBalancerId int32, configId int32, nodeId string) ApiDeleteNodeBalancerConfigNodeRequest {
	return ApiDeleteNodeBalancerConfigNodeRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
		configId: configId,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *NodeBalancersAPIService) DeleteNodeBalancerConfigNodeExecute(r ApiDeleteNodeBalancerConfigNodeRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.DeleteNodeBalancerConfigNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", url.PathEscape(parameterValueToString(r.configId, "configId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeBalancerRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
}

func (r ApiGetNodeBalancerRequest) Execute() (*NodeBalancer, *http.Response, error) {
	return r.ApiService.GetNodeBalancerExecute(r)
}

/*
GetNodeBalancer Get a NodeBalancer

Returns a single NodeBalancer you can access.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers view 12345
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @return ApiGetNodeBalancerRequest
*/
func (a *NodeBalancersAPIService) GetNodeBalancer(ctx context.Context, apiVersion string, nodeBalancerId int32) ApiGetNodeBalancerRequest {
	return ApiGetNodeBalancerRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
	}
}

// Execute executes the request
//  @return NodeBalancer
func (a *NodeBalancersAPIService) GetNodeBalancerExecute(r ApiGetNodeBalancerRequest) (*NodeBalancer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NodeBalancer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.GetNodeBalancer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeBalancerConfigRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	configId int32
}

func (r ApiGetNodeBalancerConfigRequest) Execute() (*GetNodeBalancerConfigs200ResponseDataInner, *http.Response, error) {
	return r.ApiService.GetNodeBalancerConfigExecute(r)
}

/*
GetNodeBalancerConfig Get a config

Returns configuration information for a single port of this NodeBalancer.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers config-view \
  12345 4567
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @param configId The ID of the Config to access.
 @return ApiGetNodeBalancerConfigRequest
*/
func (a *NodeBalancersAPIService) GetNodeBalancerConfig(ctx context.Context, apiVersion string, nodeBalancerId int32, configId int32) ApiGetNodeBalancerConfigRequest {
	return ApiGetNodeBalancerConfigRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
		configId: configId,
	}
}

// Execute executes the request
//  @return GetNodeBalancerConfigs200ResponseDataInner
func (a *NodeBalancersAPIService) GetNodeBalancerConfigExecute(r ApiGetNodeBalancerConfigRequest) (*GetNodeBalancerConfigs200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeBalancerConfigs200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.GetNodeBalancerConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", url.PathEscape(parameterValueToString(r.configId, "configId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeBalancerConfigNodesRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	configId int32
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetNodeBalancerConfigNodesRequest) Page(page int32) ApiGetNodeBalancerConfigNodesRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetNodeBalancerConfigNodesRequest) PageSize(pageSize int32) ApiGetNodeBalancerConfigNodesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetNodeBalancerConfigNodesRequest) Execute() (*GetNodeBalancerConfigNodes200Response, *http.Response, error) {
	return r.ApiService.GetNodeBalancerConfigNodesExecute(r)
}

/*
GetNodeBalancerConfigNodes List nodes

Returns a paginated list of NodeBalancer nodes associated with this Config. These are the backends that will be sent traffic for this port.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers nodes-list 12345 4567
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @param configId The ID of the NodeBalancer config to access.
 @return ApiGetNodeBalancerConfigNodesRequest
*/
func (a *NodeBalancersAPIService) GetNodeBalancerConfigNodes(ctx context.Context, apiVersion string, nodeBalancerId int32, configId int32) ApiGetNodeBalancerConfigNodesRequest {
	return ApiGetNodeBalancerConfigNodesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
		configId: configId,
	}
}

// Execute executes the request
//  @return GetNodeBalancerConfigNodes200Response
func (a *NodeBalancersAPIService) GetNodeBalancerConfigNodesExecute(r ApiGetNodeBalancerConfigNodesRequest) (*GetNodeBalancerConfigNodes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeBalancerConfigNodes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.GetNodeBalancerConfigNodes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", url.PathEscape(parameterValueToString(r.configId, "configId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeBalancerConfigsRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetNodeBalancerConfigsRequest) Page(page int32) ApiGetNodeBalancerConfigsRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetNodeBalancerConfigsRequest) PageSize(pageSize int32) ApiGetNodeBalancerConfigsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetNodeBalancerConfigsRequest) Execute() (*GetNodeBalancerConfigs200Response, *http.Response, error) {
	return r.ApiService.GetNodeBalancerConfigsExecute(r)
}

/*
GetNodeBalancerConfigs List configs

Returns a paginated list of NodeBalancer Configs associated with this NodeBalancer. NodeBalancer Configs represent individual ports that this NodeBalancer will accept traffic on, one Config per port.

For example, if you wanted to accept standard HTTP traffic, you would need a Config listening on port 80.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers configs-list 12345
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @return ApiGetNodeBalancerConfigsRequest
*/
func (a *NodeBalancersAPIService) GetNodeBalancerConfigs(ctx context.Context, apiVersion string, nodeBalancerId int32) ApiGetNodeBalancerConfigsRequest {
	return ApiGetNodeBalancerConfigsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
	}
}

// Execute executes the request
//  @return GetNodeBalancerConfigs200Response
func (a *NodeBalancersAPIService) GetNodeBalancerConfigsExecute(r ApiGetNodeBalancerConfigsRequest) (*GetNodeBalancerConfigs200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeBalancerConfigs200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.GetNodeBalancerConfigs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeBalancerFirewallsRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
}

func (r ApiGetNodeBalancerFirewallsRequest) Execute() (*GetNodeBalancerFirewalls200Response, *http.Response, error) {
	return r.ApiService.GetNodeBalancerFirewallsExecute(r)
}

/*
GetNodeBalancerFirewalls List NodeBalancer firewalls

View information for Firewalls assigned to this NodeBalancer.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers firewalls $nodeBalancerId
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @return ApiGetNodeBalancerFirewallsRequest
*/
func (a *NodeBalancersAPIService) GetNodeBalancerFirewalls(ctx context.Context, apiVersion string, nodeBalancerId int32) ApiGetNodeBalancerFirewallsRequest {
	return ApiGetNodeBalancerFirewallsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
	}
}

// Execute executes the request
//  @return GetNodeBalancerFirewalls200Response
func (a *NodeBalancersAPIService) GetNodeBalancerFirewallsExecute(r ApiGetNodeBalancerFirewallsRequest) (*GetNodeBalancerFirewalls200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeBalancerFirewalls200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.GetNodeBalancerFirewalls")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/firewalls"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeBalancerNodeRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	configId int32
	nodeId string
}

func (r ApiGetNodeBalancerNodeRequest) Execute() (*PostNodeBalancerRequestConfigsInnerNodesInner, *http.Response, error) {
	return r.ApiService.GetNodeBalancerNodeExecute(r)
}

/*
GetNodeBalancerNode Get a NodeBalancer's node

Returns information about a single Node, a backend for this NodeBalancer's configured port.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers node-view 12345 4567 54321
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @param configId The ID of the Config to access.
 @param nodeId The ID of the Node to access.
 @return ApiGetNodeBalancerNodeRequest
*/
func (a *NodeBalancersAPIService) GetNodeBalancerNode(ctx context.Context, apiVersion string, nodeBalancerId int32, configId int32, nodeId string) ApiGetNodeBalancerNodeRequest {
	return ApiGetNodeBalancerNodeRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
		configId: configId,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return PostNodeBalancerRequestConfigsInnerNodesInner
func (a *NodeBalancersAPIService) GetNodeBalancerNodeExecute(r ApiGetNodeBalancerNodeRequest) (*PostNodeBalancerRequestConfigsInnerNodesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostNodeBalancerRequestConfigsInnerNodesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.GetNodeBalancerNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", url.PathEscape(parameterValueToString(r.configId, "configId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeBalancerStatsRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
}

func (r ApiGetNodeBalancerStatsRequest) Execute() (*GetNodeBalancerStats200Response, *http.Response, error) {
	return r.ApiService.GetNodeBalancerStatsExecute(r)
}

/*
GetNodeBalancerStats Get NodeBalancer statistics

Returns detailed statistics about the requested NodeBalancer.


<<LB>>

---


- __OAuth scopes__.

    ```
    nodebalancers:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @return ApiGetNodeBalancerStatsRequest
*/
func (a *NodeBalancersAPIService) GetNodeBalancerStats(ctx context.Context, apiVersion string, nodeBalancerId int32) ApiGetNodeBalancerStatsRequest {
	return ApiGetNodeBalancerStatsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
	}
}

// Execute executes the request
//  @return GetNodeBalancerStats200Response
func (a *NodeBalancersAPIService) GetNodeBalancerStatsExecute(r ApiGetNodeBalancerStatsRequest) (*GetNodeBalancerStats200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeBalancerStats200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.GetNodeBalancerStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/stats"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeBalancerTypesRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
}

func (r ApiGetNodeBalancerTypesRequest) Execute() (*GetNodeBalancerTypes200Response, *http.Response, error) {
	return r.ApiService.GetNodeBalancerTypesExecute(r)
}

/*
GetNodeBalancerTypes List NodeBalancer types

Returns NodeBalancer types and prices, including any region-specific rates.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers types
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetNodeBalancerTypesRequest
*/
func (a *NodeBalancersAPIService) GetNodeBalancerTypes(ctx context.Context, apiVersion string) ApiGetNodeBalancerTypesRequest {
	return ApiGetNodeBalancerTypesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetNodeBalancerTypes200Response
func (a *NodeBalancersAPIService) GetNodeBalancerTypesExecute(r ApiGetNodeBalancerTypesRequest) (*GetNodeBalancerTypes200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeBalancerTypes200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.GetNodeBalancerTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/types"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNodeBalancersRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetNodeBalancersRequest) Page(page int32) ApiGetNodeBalancersRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetNodeBalancersRequest) PageSize(pageSize int32) ApiGetNodeBalancersRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetNodeBalancersRequest) Execute() (*GetLinodeNodeBalancers200Response, *http.Response, error) {
	return r.ApiService.GetNodeBalancersExecute(r)
}

/*
GetNodeBalancers List NodeBalancers

Returns a paginated list of NodeBalancers you have access to.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetNodeBalancersRequest
*/
func (a *NodeBalancersAPIService) GetNodeBalancers(ctx context.Context, apiVersion string) ApiGetNodeBalancersRequest {
	return ApiGetNodeBalancersRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetLinodeNodeBalancers200Response
func (a *NodeBalancersAPIService) GetNodeBalancersExecute(r ApiGetNodeBalancersRequest) (*GetLinodeNodeBalancers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetLinodeNodeBalancers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.GetNodeBalancers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostNodeBalancerRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	postNodeBalancerRequest *PostNodeBalancerRequest
}

// Information about the NodeBalancer to create.
func (r ApiPostNodeBalancerRequest) PostNodeBalancerRequest(postNodeBalancerRequest PostNodeBalancerRequest) ApiPostNodeBalancerRequest {
	r.postNodeBalancerRequest = &postNodeBalancerRequest
	return r
}

func (r ApiPostNodeBalancerRequest) Execute() (*NodeBalancer, *http.Response, error) {
	return r.ApiService.PostNodeBalancerExecute(r)
}

/*
PostNodeBalancer Create a NodeBalancer

Creates a NodeBalancer in the requested Region. Only available in [regions](https://techdocs.akamai.com/linode-api/reference/get-regions) with "NodeBalancers" in their `capabilities`.

NodeBalancers require a port Config with at least one backend Node to start serving requests.

When using the Linode CLI to create a NodeBalancer, first create a NodeBalancer without any Configs. Then, create Configs and Nodes for that NodeBalancer with the respective [Create a config](https://techdocs.akamai.com/linode-api/reference/post-node-balancer-config) and [Create a node](https://techdocs.akamai.com/linode-api/reference/post-node-balancer-node) operations.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers create \
  --region us-east \
  --label balancer12345 \
  --client_conn_throttle 0
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostNodeBalancerRequest
*/
func (a *NodeBalancersAPIService) PostNodeBalancer(ctx context.Context, apiVersion string) ApiPostNodeBalancerRequest {
	return ApiPostNodeBalancerRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return NodeBalancer
func (a *NodeBalancersAPIService) PostNodeBalancerExecute(r ApiPostNodeBalancerRequest) (*NodeBalancer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NodeBalancer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.PostNodeBalancer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postNodeBalancerRequest == nil {
		return localVarReturnValue, nil, reportError("postNodeBalancerRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postNodeBalancerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostNodeBalancerConfigRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	getNodeBalancerConfigs200ResponseDataInner *GetNodeBalancerConfigs200ResponseDataInner
}

// Information about the port to configure.
func (r ApiPostNodeBalancerConfigRequest) GetNodeBalancerConfigs200ResponseDataInner(getNodeBalancerConfigs200ResponseDataInner GetNodeBalancerConfigs200ResponseDataInner) ApiPostNodeBalancerConfigRequest {
	r.getNodeBalancerConfigs200ResponseDataInner = &getNodeBalancerConfigs200ResponseDataInner
	return r
}

func (r ApiPostNodeBalancerConfigRequest) Execute() (*GetNodeBalancerConfigs200ResponseDataInner, *http.Response, error) {
	return r.ApiService.PostNodeBalancerConfigExecute(r)
}

/*
PostNodeBalancerConfig Create a config

Creates a NodeBalancer Config, which allows the NodeBalancer to accept traffic on a new port. You will need to add NodeBalancer Nodes to the new Config before it can actually serve requests.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers config-create 12345 \
  --port 443 \
  --protocol https \
  --algorithm roundrobin \
  --stickiness http_cookie \
  --check http_body \
  --check_interval 90 \
  --check_timeout 10 \
  --check_attempts 3 \
  --check_path "/test" \
  --check_body "it works" \
  --check_passive true \
  --proxy_protocol "none" \
  --ssl_cert "-----BEGIN CERTIFICATE-----
              CERTIFICATE_INFORMATION
              -----END CERTIFICATE-----" \
  --ssl_key "-----BEGIN PRIVATE KEY-----
             PRIVATE_KEY_INFORMATION
             -----END PRIVATE KEY-----" \
  --cipher_suite recommended
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @return ApiPostNodeBalancerConfigRequest
*/
func (a *NodeBalancersAPIService) PostNodeBalancerConfig(ctx context.Context, apiVersion string, nodeBalancerId int32) ApiPostNodeBalancerConfigRequest {
	return ApiPostNodeBalancerConfigRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
	}
}

// Execute executes the request
//  @return GetNodeBalancerConfigs200ResponseDataInner
func (a *NodeBalancersAPIService) PostNodeBalancerConfigExecute(r ApiPostNodeBalancerConfigRequest) (*GetNodeBalancerConfigs200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeBalancerConfigs200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.PostNodeBalancerConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getNodeBalancerConfigs200ResponseDataInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostNodeBalancerNodeRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	configId int32
	postNodeBalancerNodeRequest *PostNodeBalancerNodeRequest
}

// Information about the Node to create.
func (r ApiPostNodeBalancerNodeRequest) PostNodeBalancerNodeRequest(postNodeBalancerNodeRequest PostNodeBalancerNodeRequest) ApiPostNodeBalancerNodeRequest {
	r.postNodeBalancerNodeRequest = &postNodeBalancerNodeRequest
	return r
}

func (r ApiPostNodeBalancerNodeRequest) Execute() (*PostNodeBalancerRequestConfigsInnerNodesInner, *http.Response, error) {
	return r.ApiService.PostNodeBalancerNodeExecute(r)
}

/*
PostNodeBalancerNode Create a node

Creates a NodeBalancer Node, a backend that can accept traffic for this NodeBalancer Config. Nodes are routed requests on the configured port based on their status.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers node-create \
  12345 4567 \
  --address 192.168.210.120:80 \
  --label node54321 \
  --weight 50 \
  --mode accept
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @param configId The ID of the NodeBalancer config to access.
 @return ApiPostNodeBalancerNodeRequest
*/
func (a *NodeBalancersAPIService) PostNodeBalancerNode(ctx context.Context, apiVersion string, nodeBalancerId int32, configId int32) ApiPostNodeBalancerNodeRequest {
	return ApiPostNodeBalancerNodeRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
		configId: configId,
	}
}

// Execute executes the request
//  @return PostNodeBalancerRequestConfigsInnerNodesInner
func (a *NodeBalancersAPIService) PostNodeBalancerNodeExecute(r ApiPostNodeBalancerNodeRequest) (*PostNodeBalancerRequestConfigsInnerNodesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostNodeBalancerRequestConfigsInnerNodesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.PostNodeBalancerNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", url.PathEscape(parameterValueToString(r.configId, "configId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postNodeBalancerNodeRequest == nil {
		return localVarReturnValue, nil, reportError("postNodeBalancerNodeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postNodeBalancerNodeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRebuildNodeBalancerConfigRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	configId int32
	postRebuildNodeBalancerConfigRequest *PostRebuildNodeBalancerConfigRequest
}

// Information about the NodeBalancer Config to rebuild.
func (r ApiPostRebuildNodeBalancerConfigRequest) PostRebuildNodeBalancerConfigRequest(postRebuildNodeBalancerConfigRequest PostRebuildNodeBalancerConfigRequest) ApiPostRebuildNodeBalancerConfigRequest {
	r.postRebuildNodeBalancerConfigRequest = &postRebuildNodeBalancerConfigRequest
	return r
}

func (r ApiPostRebuildNodeBalancerConfigRequest) Execute() (*GetNodeBalancerConfigs200ResponseDataInner, *http.Response, error) {
	return r.ApiService.PostRebuildNodeBalancerConfigExecute(r)
}

/*
PostRebuildNodeBalancerConfig Rebuild a config

Rebuilds a NodeBalancer Config and its Nodes that you have permission to modify.

Use this operation to update a NodeBalancer's Config and Nodes with a single request.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers config-rebuild \
  12345 4567 \
  --port 443 \
  --protocol https \
  --algorithm roundrobin \
  --stickiness http_cookie \
  --check http_body \
  --check_interval 90 \
  --check_timeout 10 \
  --check_attempts 3 \
  --check_path "/test" \
  --check_body "it works" \
  --check_passive true \
  --proxy_protocol "none" \
  --ssl_cert "-----BEGIN CERTIFICATE-----
              CERTIFICATE_INFORMATION
              -----END CERTIFICATE-----" \
  --ssl_key "-----BEGIN PRIVATE KEY-----
             PRIVATE_KEY_INFORMATION
             -----END PRIVATE KEY-----" \
  --cipher_suite recommended \
  --nodes '{"address":"192.168.210.120:80","label":"node1","weight":50,"mode":"accept"}' \
  --nodes '{"address":"192.168.210.122:80","label":"node2","weight":50,"mode":"accept"}'
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @param configId The ID of the Config to access.
 @return ApiPostRebuildNodeBalancerConfigRequest
*/
func (a *NodeBalancersAPIService) PostRebuildNodeBalancerConfig(ctx context.Context, apiVersion string, nodeBalancerId int32, configId int32) ApiPostRebuildNodeBalancerConfigRequest {
	return ApiPostRebuildNodeBalancerConfigRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
		configId: configId,
	}
}

// Execute executes the request
//  @return GetNodeBalancerConfigs200ResponseDataInner
func (a *NodeBalancersAPIService) PostRebuildNodeBalancerConfigExecute(r ApiPostRebuildNodeBalancerConfigRequest) (*GetNodeBalancerConfigs200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeBalancerConfigs200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.PostRebuildNodeBalancerConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/rebuild"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", url.PathEscape(parameterValueToString(r.configId, "configId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postRebuildNodeBalancerConfigRequest == nil {
		return localVarReturnValue, nil, reportError("postRebuildNodeBalancerConfigRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postRebuildNodeBalancerConfigRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutNodeBalancerRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	nodeBalancer *NodeBalancer
}

// The information to update.
func (r ApiPutNodeBalancerRequest) NodeBalancer(nodeBalancer NodeBalancer) ApiPutNodeBalancerRequest {
	r.nodeBalancer = &nodeBalancer
	return r
}

func (r ApiPutNodeBalancerRequest) Execute() (*NodeBalancer, *http.Response, error) {
	return r.ApiService.PutNodeBalancerExecute(r)
}

/*
PutNodeBalancer Update a NodeBalancer

Updates information about a NodeBalancer you can access.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers update 12345 \
  --label balancer12345 \
  --client_conn_throttle 0
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @return ApiPutNodeBalancerRequest
*/
func (a *NodeBalancersAPIService) PutNodeBalancer(ctx context.Context, apiVersion string, nodeBalancerId int32) ApiPutNodeBalancerRequest {
	return ApiPutNodeBalancerRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
	}
}

// Execute executes the request
//  @return NodeBalancer
func (a *NodeBalancersAPIService) PutNodeBalancerExecute(r ApiPutNodeBalancerRequest) (*NodeBalancer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NodeBalancer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.PutNodeBalancer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nodeBalancer == nil {
		return localVarReturnValue, nil, reportError("nodeBalancer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nodeBalancer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutNodeBalancerConfigRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	configId int32
	getNodeBalancerConfigs200ResponseDataInner *GetNodeBalancerConfigs200ResponseDataInner
}

// The fields to update.
func (r ApiPutNodeBalancerConfigRequest) GetNodeBalancerConfigs200ResponseDataInner(getNodeBalancerConfigs200ResponseDataInner GetNodeBalancerConfigs200ResponseDataInner) ApiPutNodeBalancerConfigRequest {
	r.getNodeBalancerConfigs200ResponseDataInner = &getNodeBalancerConfigs200ResponseDataInner
	return r
}

func (r ApiPutNodeBalancerConfigRequest) Execute() (*GetNodeBalancerConfigs200ResponseDataInner, *http.Response, error) {
	return r.ApiService.PutNodeBalancerConfigExecute(r)
}

/*
PutNodeBalancerConfig Update a config

Updates the configuration for a single port on a NodeBalancer.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers config-update \
  12345 4567 \
  --port 443 \
  --protocol https \
  --algorithm roundrobin \
  --stickiness http_cookie \
  --check http_body \
  --check_interval 90 \
  --check_timeout 10 \
  --check_attempts 3 \
  --check_path "/test" \
  --check_body "it works" \
  --check_passive true \
  --proxy_protocol "none" \
  --ssl_cert "-----BEGIN CERTIFICATE-----
              CERTIFICATE_INFORMATION
              -----END CERTIFICATE-----" \
  --ssl_key "-----BEGIN PRIVATE KEY-----
             PRIVATE_KEY_INFORMATION
             -----END PRIVATE KEY-----" \
  --cipher_suite recommended
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @param configId The ID of the Config to access.
 @return ApiPutNodeBalancerConfigRequest
*/
func (a *NodeBalancersAPIService) PutNodeBalancerConfig(ctx context.Context, apiVersion string, nodeBalancerId int32, configId int32) ApiPutNodeBalancerConfigRequest {
	return ApiPutNodeBalancerConfigRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
		configId: configId,
	}
}

// Execute executes the request
//  @return GetNodeBalancerConfigs200ResponseDataInner
func (a *NodeBalancersAPIService) PutNodeBalancerConfigExecute(r ApiPutNodeBalancerConfigRequest) (*GetNodeBalancerConfigs200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNodeBalancerConfigs200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.PutNodeBalancerConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", url.PathEscape(parameterValueToString(r.configId, "configId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getNodeBalancerConfigs200ResponseDataInner == nil {
		return localVarReturnValue, nil, reportError("getNodeBalancerConfigs200ResponseDataInner is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getNodeBalancerConfigs200ResponseDataInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutNodeBalancerNodeRequest struct {
	ctx context.Context
	ApiService *NodeBalancersAPIService
	apiVersion string
	nodeBalancerId int32
	configId int32
	nodeId string
	postNodeBalancerRequestConfigsInnerNodesInner *PostNodeBalancerRequestConfigsInnerNodesInner
}

// The fields to update.
func (r ApiPutNodeBalancerNodeRequest) PostNodeBalancerRequestConfigsInnerNodesInner(postNodeBalancerRequestConfigsInnerNodesInner PostNodeBalancerRequestConfigsInnerNodesInner) ApiPutNodeBalancerNodeRequest {
	r.postNodeBalancerRequestConfigsInnerNodesInner = &postNodeBalancerRequestConfigsInnerNodesInner
	return r
}

func (r ApiPutNodeBalancerNodeRequest) Execute() (*PostNodeBalancerRequestConfigsInnerNodesInner, *http.Response, error) {
	return r.ApiService.PutNodeBalancerNodeExecute(r)
}

/*
PutNodeBalancerNode Update a node

Updates information about a Node, a backend for this NodeBalancer's configured port.


<<LB>>

---


- __CLI__.

    ```
    linode-cli nodebalancers node-update \
  12345 4567 54321 \
  --address 192.168.210.120:80 \
  --label node54321 \
  --weight 50 \
  --mode accept
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    nodebalancers:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param nodeBalancerId The ID of the NodeBalancer to access.
 @param configId The ID of the Config to access.
 @param nodeId The ID of the Node to access.
 @return ApiPutNodeBalancerNodeRequest
*/
func (a *NodeBalancersAPIService) PutNodeBalancerNode(ctx context.Context, apiVersion string, nodeBalancerId int32, configId int32, nodeId string) ApiPutNodeBalancerNodeRequest {
	return ApiPutNodeBalancerNodeRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		nodeBalancerId: nodeBalancerId,
		configId: configId,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return PostNodeBalancerRequestConfigsInnerNodesInner
func (a *NodeBalancersAPIService) PutNodeBalancerNodeExecute(r ApiPutNodeBalancerNodeRequest) (*PostNodeBalancerRequestConfigsInnerNodesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostNodeBalancerRequestConfigsInnerNodesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NodeBalancersAPIService.PutNodeBalancerNode")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/nodebalancers/{nodeBalancerId}/configs/{configId}/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeBalancerId"+"}", url.PathEscape(parameterValueToString(r.nodeBalancerId, "nodeBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configId"+"}", url.PathEscape(parameterValueToString(r.configId, "configId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", url.PathEscape(parameterValueToString(r.nodeId, "nodeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postNodeBalancerRequestConfigsInnerNodesInner == nil {
		return localVarReturnValue, nil, reportError("postNodeBalancerRequestConfigsInnerNodesInner is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postNodeBalancerRequestConfigsInnerNodesInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
