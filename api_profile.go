/*
Linode API

[Read the API documentation](https://techdocs.akamai.com/linode-api/reference/api).

API version: 4.189.2
Contact: support@linode.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProfileAPIService ProfileAPI service
type ProfileAPIService service

type ApiDeletePersonalAccessTokenRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	tokenId int32
}

func (r ApiDeletePersonalAccessTokenRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeletePersonalAccessTokenExecute(r)
}

/*
DeletePersonalAccessToken Revoke a personal access token

Revokes a Personal Access Token. The token will be invalidated immediately, and requests using that token will fail with a 401. It is possible to revoke access to the token making the request to revoke a token, but keep in mind that doing so could lose you access to the api and require you to create a new token through some other means.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile token-delete 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param tokenId The ID of the token to access.
 @return ApiDeletePersonalAccessTokenRequest
*/
func (a *ProfileAPIService) DeletePersonalAccessToken(ctx context.Context, apiVersion string, tokenId int32) ApiDeletePersonalAccessTokenRequest {
	return ApiDeletePersonalAccessTokenRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		tokenId: tokenId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) DeletePersonalAccessTokenExecute(r ApiDeletePersonalAccessTokenRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeletePersonalAccessToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/tokens/{tokenId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tokenId"+"}", url.PathEscape(parameterValueToString(r.tokenId, "tokenId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProfileAppRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	appId int32
}

func (r ApiDeleteProfileAppRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteProfileAppExecute(r)
}

/*
DeleteProfileApp Revoke app access

Expires this app token. This token may no longer be used to access your Account.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile app-delete 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param appId The authorized app ID to manage.
 @return ApiDeleteProfileAppRequest
*/
func (a *ProfileAPIService) DeleteProfileApp(ctx context.Context, apiVersion string, appId int32) ApiDeleteProfileAppRequest {
	return ApiDeleteProfileAppRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		appId: appId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) DeleteProfileAppExecute(r ApiDeleteProfileAppRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteProfileApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/apps/{appId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteProfilePhoneNumberRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiDeleteProfilePhoneNumberRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteProfilePhoneNumberExecute(r)
}

/*
DeleteProfilePhoneNumber Delete a phone number

Delete the verified phone number for the User making this request.

Use this operation to opt out of SMS messages for the requesting User after a phone number has been verified with the [Verify a phone number](https://techdocs.akamai.com/linode-api/reference/post-profile-phone-number-verify) operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli phone delete
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiDeleteProfilePhoneNumberRequest
*/
func (a *ProfileAPIService) DeleteProfilePhoneNumber(ctx context.Context, apiVersion string) ApiDeleteProfilePhoneNumberRequest {
	return ApiDeleteProfilePhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) DeleteProfilePhoneNumberExecute(r ApiDeleteProfilePhoneNumberRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteProfilePhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/phone-number"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSshKeyRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	sshKeyId int32
}

func (r ApiDeleteSshKeyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteSshKeyExecute(r)
}

/*
DeleteSshKey Delete an SSH key

Deletes an SSH Key you have access to.

__Note__. deleting an SSH Key will _not_ remove it from any Linode or Disk that was deployed with `authorized_keys`. In those cases, the keys must be manually deleted on the Linode or Disk. This operation will only delete the key's association from your Profile.


<<LB>>

---


- __CLI__.

    ```
    linode-cli sshkeys delete 42
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param sshKeyId The ID of the SSHKey.
 @return ApiDeleteSshKeyRequest
*/
func (a *ProfileAPIService) DeleteSshKey(ctx context.Context, apiVersion string, sshKeyId int32) ApiDeleteSshKeyRequest {
	return ApiDeleteSshKeyRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		sshKeyId: sshKeyId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) DeleteSshKeyExecute(r ApiDeleteSshKeyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteSshKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/sshkeys/{sshKeyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sshKeyId"+"}", url.PathEscape(parameterValueToString(r.sshKeyId, "sshKeyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTrustedDeviceRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	deviceId int32
}

func (r ApiDeleteTrustedDeviceRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteTrustedDeviceExecute(r)
}

/*
DeleteTrustedDevice Revoke a trusted device

Revoke an active TrustedDevice for your User.  Once a TrustedDevice is revoked, this device will have to log in again before accessing your Linode account.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile device-revoke 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param deviceId The ID of the TrustedDevice.
 @return ApiDeleteTrustedDeviceRequest
*/
func (a *ProfileAPIService) DeleteTrustedDevice(ctx context.Context, apiVersion string, deviceId int32) ApiDeleteTrustedDeviceRequest {
	return ApiDeleteTrustedDeviceRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) DeleteTrustedDeviceExecute(r ApiDeleteTrustedDeviceRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.DeleteTrustedDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/devices/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDevicesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiGetDevicesRequest) Execute() (*GetDevices200Response, *http.Response, error) {
	return r.ApiService.GetDevicesExecute(r)
}

/*
GetDevices List trusted devices

Returns a paginated list of active TrustedDevices for your User. Browsers with an active Remember Me Session are logged into your account until the session expires or is revoked.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile devices-list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetDevicesRequest
*/
func (a *ProfileAPIService) GetDevices(ctx context.Context, apiVersion string) ApiGetDevicesRequest {
	return ApiGetDevicesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetDevices200Response
func (a *ProfileAPIService) GetDevicesExecute(r ApiGetDevicesRequest) (*GetDevices200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDevices200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPersonalAccessTokenRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	tokenId int32
}

func (r ApiGetPersonalAccessTokenRequest) Execute() (*GetPersonalAccessTokens200ResponseDataInner, *http.Response, error) {
	return r.ApiService.GetPersonalAccessTokenExecute(r)
}

/*
GetPersonalAccessToken Get a personal access token

Returns a single Personal Access Token.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile token-view 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param tokenId The ID of the token to access.
 @return ApiGetPersonalAccessTokenRequest
*/
func (a *ProfileAPIService) GetPersonalAccessToken(ctx context.Context, apiVersion string, tokenId int32) ApiGetPersonalAccessTokenRequest {
	return ApiGetPersonalAccessTokenRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		tokenId: tokenId,
	}
}

// Execute executes the request
//  @return GetPersonalAccessTokens200ResponseDataInner
func (a *ProfileAPIService) GetPersonalAccessTokenExecute(r ApiGetPersonalAccessTokenRequest) (*GetPersonalAccessTokens200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPersonalAccessTokens200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetPersonalAccessToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/tokens/{tokenId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tokenId"+"}", url.PathEscape(parameterValueToString(r.tokenId, "tokenId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPersonalAccessTokensRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiGetPersonalAccessTokensRequest) Execute() (*GetPersonalAccessTokens200Response, *http.Response, error) {
	return r.ApiService.GetPersonalAccessTokensExecute(r)
}

/*
GetPersonalAccessTokens List personal access tokens

Returns a paginated list of Personal Access Tokens currently active for your User.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile tokens-list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetPersonalAccessTokensRequest
*/
func (a *ProfileAPIService) GetPersonalAccessTokens(ctx context.Context, apiVersion string) ApiGetPersonalAccessTokensRequest {
	return ApiGetPersonalAccessTokensRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetPersonalAccessTokens200Response
func (a *ProfileAPIService) GetPersonalAccessTokensExecute(r ApiGetPersonalAccessTokensRequest) (*GetPersonalAccessTokens200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPersonalAccessTokens200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetPersonalAccessTokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiGetProfileRequest) Execute() (*GetProfile200Response, *http.Response, error) {
	return r.ApiService.GetProfileExecute(r)
}

/*
GetProfile Get a profile

Returns information about the current User. This can be used to see who is acting in applications where more than one token is managed. For example, in third-party OAuth applications.

This operation is always accessible, no matter what OAuth scopes the acting token has.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile view
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetProfileRequest
*/
func (a *ProfileAPIService) GetProfile(ctx context.Context, apiVersion string) ApiGetProfileRequest {
	return ApiGetProfileRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetProfile200Response
func (a *ProfileAPIService) GetProfileExecute(r ApiGetProfileRequest) (*GetProfile200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProfile200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileAppRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	appId int32
}

func (r ApiGetProfileAppRequest) Execute() (*GetProfileApps200ResponseDataInner, *http.Response, error) {
	return r.ApiService.GetProfileAppExecute(r)
}

/*
GetProfileApp Get an authorized app

Returns information about a single app you've authorized to access your Account.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile app-view 1234
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param appId The authorized app ID to manage.
 @return ApiGetProfileAppRequest
*/
func (a *ProfileAPIService) GetProfileApp(ctx context.Context, apiVersion string, appId int32) ApiGetProfileAppRequest {
	return ApiGetProfileAppRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		appId: appId,
	}
}

// Execute executes the request
//  @return GetProfileApps200ResponseDataInner
func (a *ProfileAPIService) GetProfileAppExecute(r ApiGetProfileAppRequest) (*GetProfileApps200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProfileApps200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileApp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/apps/{appId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"appId"+"}", url.PathEscape(parameterValueToString(r.appId, "appId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileAppsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetProfileAppsRequest) Page(page int32) ApiGetProfileAppsRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetProfileAppsRequest) PageSize(pageSize int32) ApiGetProfileAppsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetProfileAppsRequest) Execute() (*GetProfileApps200Response, *http.Response, error) {
	return r.ApiService.GetProfileAppsExecute(r)
}

/*
GetProfileApps List authorized apps

This is a collection of OAuth apps that you've given access to your Account, and includes the level of access granted.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile apps-list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetProfileAppsRequest
*/
func (a *ProfileAPIService) GetProfileApps(ctx context.Context, apiVersion string) ApiGetProfileAppsRequest {
	return ApiGetProfileAppsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetProfileApps200Response
func (a *ProfileAPIService) GetProfileAppsExecute(r ApiGetProfileAppsRequest) (*GetProfileApps200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProfileApps200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileApps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/apps"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileGrantsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiGetProfileGrantsRequest) Execute() (*GetUserGrants200Response, *http.Response, error) {
	return r.ApiService.GetProfileGrantsExecute(r)
}

/*
GetProfileGrants List grants

This returns a GrantsResponse describing what the acting User has been granted access to.  For unrestricted users, this will return a  204 and no body because unrestricted users have access to everything without grants.  This will not return information about entities you do not have access to.  This operation is useful when writing third-party OAuth applications to see what options you should present to the acting User.

For example, if they do not have `global.add_linodes`, you might not display a button to deploy a new Linode.

Any client may run this operation; no OAuth scopes are required.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetProfileGrantsRequest
*/
func (a *ProfileAPIService) GetProfileGrants(ctx context.Context, apiVersion string) ApiGetProfileGrantsRequest {
	return ApiGetProfileGrantsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetUserGrants200Response
func (a *ProfileAPIService) GetProfileGrantsExecute(r ApiGetProfileGrantsRequest) (*GetUserGrants200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUserGrants200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileGrants")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/grants"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileLoginRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	loginId int32
}

func (r ApiGetProfileLoginRequest) Execute() (*GetAccountLogins200ResponseDataInner, *http.Response, error) {
	return r.ApiService.GetProfileLoginExecute(r)
}

/*
GetProfileLogin Get a profile's login

Returns a login object displaying information about a successful account login from this user.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile login-view 1234
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param loginId The ID of the login object to access.
 @return ApiGetProfileLoginRequest
*/
func (a *ProfileAPIService) GetProfileLogin(ctx context.Context, apiVersion string, loginId int32) ApiGetProfileLoginRequest {
	return ApiGetProfileLoginRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		loginId: loginId,
	}
}

// Execute executes the request
//  @return GetAccountLogins200ResponseDataInner
func (a *ProfileAPIService) GetProfileLoginExecute(r ApiGetProfileLoginRequest) (*GetAccountLogins200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountLogins200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileLogin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/logins/{loginId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"loginId"+"}", url.PathEscape(parameterValueToString(r.loginId, "loginId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileLoginsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiGetProfileLoginsRequest) Execute() (*GetAccountLogins200Response, *http.Response, error) {
	return r.ApiService.GetProfileLoginsExecute(r)
}

/*
GetProfileLogins List logins

Returns a collection of successful account logins from this user during the last 90 days.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile logins-list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetProfileLoginsRequest
*/
func (a *ProfileAPIService) GetProfileLogins(ctx context.Context, apiVersion string) ApiGetProfileLoginsRequest {
	return ApiGetProfileLoginsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetAccountLogins200Response
func (a *ProfileAPIService) GetProfileLoginsExecute(r ApiGetProfileLoginsRequest) (*GetAccountLogins200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAccountLogins200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetProfileLogins")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/logins"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSecurityQuestionsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiGetSecurityQuestionsRequest) Execute() (*GetSecurityQuestions200Response, *http.Response, error) {
	return r.ApiService.GetSecurityQuestionsExecute(r)
}

/*
GetSecurityQuestions List security questions

Returns a collection of security questions and their responses, if any, for your User Profile.


<<LB>>

---


- __CLI__.

    ```
    linode-cli security-questions list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetSecurityQuestionsRequest
*/
func (a *ProfileAPIService) GetSecurityQuestions(ctx context.Context, apiVersion string) ApiGetSecurityQuestionsRequest {
	return ApiGetSecurityQuestionsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetSecurityQuestions200Response
func (a *ProfileAPIService) GetSecurityQuestionsExecute(r ApiGetSecurityQuestionsRequest) (*GetSecurityQuestions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSecurityQuestions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetSecurityQuestions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/security-questions"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSshKeyRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	sshKeyId int32
}

func (r ApiGetSshKeyRequest) Execute() (*GetSshKeys200ResponseDataInner, *http.Response, error) {
	return r.ApiService.GetSshKeyExecute(r)
}

/*
GetSshKey Get an SSH key

Returns a single SSH Key object identified by `id` that you have access to view.


<<LB>>

---


- __CLI__.

    ```
    linode-cli sshkeys view 42
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param sshKeyId The ID of the SSHKey.
 @return ApiGetSshKeyRequest
*/
func (a *ProfileAPIService) GetSshKey(ctx context.Context, apiVersion string, sshKeyId int32) ApiGetSshKeyRequest {
	return ApiGetSshKeyRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		sshKeyId: sshKeyId,
	}
}

// Execute executes the request
//  @return GetSshKeys200ResponseDataInner
func (a *ProfileAPIService) GetSshKeyExecute(r ApiGetSshKeyRequest) (*GetSshKeys200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSshKeys200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetSshKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/sshkeys/{sshKeyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sshKeyId"+"}", url.PathEscape(parameterValueToString(r.sshKeyId, "sshKeyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSshKeysRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	page *int32
	pageSize *int32
}

// The page of a collection to return.
func (r ApiGetSshKeysRequest) Page(page int32) ApiGetSshKeysRequest {
	r.page = &page
	return r
}

// The number of items to return per page.
func (r ApiGetSshKeysRequest) PageSize(pageSize int32) ApiGetSshKeysRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetSshKeysRequest) Execute() (*GetSshKeys200Response, *http.Response, error) {
	return r.ApiService.GetSshKeysExecute(r)
}

/*
GetSshKeys List SSH keys

Returns a collection of SSH Keys you've added to your Profile.


<<LB>>

---


- __CLI__.

    ```
    linode-cli sshkeys list
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetSshKeysRequest
*/
func (a *ProfileAPIService) GetSshKeys(ctx context.Context, apiVersion string) ApiGetSshKeysRequest {
	return ApiGetSshKeysRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetSshKeys200Response
func (a *ProfileAPIService) GetSshKeysExecute(r ApiGetSshKeysRequest) (*GetSshKeys200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSshKeys200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetSshKeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/sshkeys"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrustedDeviceRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	deviceId int32
}

func (r ApiGetTrustedDeviceRequest) Execute() (*GetDevices200ResponseDataInner, *http.Response, error) {
	return r.ApiService.GetTrustedDeviceExecute(r)
}

/*
GetTrustedDevice Get a trusted device

Returns a single active TrustedDevice for your User.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile device-view 123
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param deviceId The ID of the TrustedDevice.
 @return ApiGetTrustedDeviceRequest
*/
func (a *ProfileAPIService) GetTrustedDevice(ctx context.Context, apiVersion string, deviceId int32) ApiGetTrustedDeviceRequest {
	return ApiGetTrustedDeviceRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return GetDevices200ResponseDataInner
func (a *ProfileAPIService) GetTrustedDeviceExecute(r ApiGetTrustedDeviceRequest) (*GetDevices200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDevices200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetTrustedDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/devices/{deviceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"deviceId"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserPreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiGetUserPreferencesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUserPreferencesExecute(r)
}

/*
GetUserPreferences Get user preferences

View a list of user preferences tied to the OAuth client that generated the token making the request. The user preferences endpoints allow consumers of the API to store arbitrary JSON data, such as a user's font size preference or preferred display name. User preferences are available for each OAuth client registered to your account, and as such an account can have multiple user preferences.


<<LB>>

---


- __OAuth scopes__.

    ```
    account:read_only
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiGetUserPreferencesRequest
*/
func (a *ProfileAPIService) GetUserPreferences(ctx context.Context, apiVersion string) ApiGetUserPreferencesRequest {
	return ApiGetUserPreferencesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) GetUserPreferencesExecute(r ApiGetUserPreferencesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.GetUserPreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostAddSshKeyRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	getSshKeys200ResponseDataInner *GetSshKeys200ResponseDataInner
}

// Add SSH Key.
func (r ApiPostAddSshKeyRequest) GetSshKeys200ResponseDataInner(getSshKeys200ResponseDataInner GetSshKeys200ResponseDataInner) ApiPostAddSshKeyRequest {
	r.getSshKeys200ResponseDataInner = &getSshKeys200ResponseDataInner
	return r
}

func (r ApiPostAddSshKeyRequest) Execute() (*GetSshKeys200ResponseDataInner, *http.Response, error) {
	return r.ApiService.PostAddSshKeyExecute(r)
}

/*
PostAddSshKey Add an SSH key

Adds an SSH Key to your Account profile.


<<LB>>

---


- __CLI__.

    ```
    linode-cli sshkeys create \
  --label "My SSH Key" \
  --ssh_key "ssh-rsa AAAA_valid_public_ssh_key_123456785== user@their-computer"
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostAddSshKeyRequest
*/
func (a *ProfileAPIService) PostAddSshKey(ctx context.Context, apiVersion string) ApiPostAddSshKeyRequest {
	return ApiPostAddSshKeyRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetSshKeys200ResponseDataInner
func (a *ProfileAPIService) PostAddSshKeyExecute(r ApiPostAddSshKeyRequest) (*GetSshKeys200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSshKeys200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostAddSshKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/sshkeys"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getSshKeys200ResponseDataInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostPersonalAccessTokenRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	postPersonalAccessTokenRequest *PostPersonalAccessTokenRequest
}

// Information about the requested token.
func (r ApiPostPersonalAccessTokenRequest) PostPersonalAccessTokenRequest(postPersonalAccessTokenRequest PostPersonalAccessTokenRequest) ApiPostPersonalAccessTokenRequest {
	r.postPersonalAccessTokenRequest = &postPersonalAccessTokenRequest
	return r
}

func (r ApiPostPersonalAccessTokenRequest) Execute() (*GetPersonalAccessTokens200ResponseDataInner, *http.Response, error) {
	return r.ApiService.PostPersonalAccessTokenExecute(r)
}

/*
PostPersonalAccessToken Create a personal access token

Creates a Personal Access Token for your User. The raw token will be returned in the response, but will never be returned again afterward so be sure to take note of it. You may create a token with _at most_ the scopes of your current token. The created token will be able to access your Account until the given expiry, or until it is revoked. __Parent and child accounts__ In a [parent and child account](https://www.linode.com/docs/guides/parent-child-accounts/) environment, the following apply:

- If you're using a child account parent user (proxy user), you can't create this form of token. The only token available to a proxy user is one that lets you run operations in a child account. These are created with the [Create a proxy user token](https://techdocs.akamai.com/linode-api/reference/post-child-account-token) operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile token-create \
  --scopes '*' \
  --expiry '2018-01-01T13:46:32' \
  --label linode-cli
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostPersonalAccessTokenRequest
*/
func (a *ProfileAPIService) PostPersonalAccessToken(ctx context.Context, apiVersion string) ApiPostPersonalAccessTokenRequest {
	return ApiPostPersonalAccessTokenRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetPersonalAccessTokens200ResponseDataInner
func (a *ProfileAPIService) PostPersonalAccessTokenExecute(r ApiPostPersonalAccessTokenRequest) (*GetPersonalAccessTokens200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPersonalAccessTokens200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostPersonalAccessToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postPersonalAccessTokenRequest == nil {
		return localVarReturnValue, nil, reportError("postPersonalAccessTokenRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postPersonalAccessTokenRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProfilePhoneNumberRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	postProfilePhoneNumberRequest *PostProfilePhoneNumberRequest
}

// Enter a phone number and country code for verification.
func (r ApiPostProfilePhoneNumberRequest) PostProfilePhoneNumberRequest(postProfilePhoneNumberRequest PostProfilePhoneNumberRequest) ApiPostProfilePhoneNumberRequest {
	r.postProfilePhoneNumberRequest = &postProfilePhoneNumberRequest
	return r
}

func (r ApiPostProfilePhoneNumberRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostProfilePhoneNumberExecute(r)
}

/*
PostProfilePhoneNumber Send a phone number verification code

Send a one-time verification code via SMS message to the submitted phone number. Providing your phone number helps ensure you can securely access your Account in case other ways to connect are lost. Your phone number is only used to verify your identity by sending an SMS message. Standard carrier messaging fees may apply.

- By accessing this operation you are opting in to receive SMS messages. You can opt out of SMS messages by running the [Delete a phone number](https://techdocs.akamai.com/linode-api/reference/delete-profile-phone-number) operation after your phone number is verified.

- Verification codes are valid for 10 minutes after they are sent.

- Subsequent requests made prior to code expiration result in sending the same code.

Once a verification code is received, verify your phone number with the [Verify a phone number](https://techdocs.akamai.com/linode-api/reference/post-profile-phone-number-verify) operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli phone sms-code-send \
  --iso-code US \
  --phone-number 555-555-5555
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostProfilePhoneNumberRequest
*/
func (a *ProfileAPIService) PostProfilePhoneNumber(ctx context.Context, apiVersion string) ApiPostProfilePhoneNumberRequest {
	return ApiPostProfilePhoneNumberRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) PostProfilePhoneNumberExecute(r ApiPostProfilePhoneNumberRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostProfilePhoneNumber")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/phone-number"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postProfilePhoneNumberRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostProfilePhoneNumberVerifyRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	postProfilePhoneNumberVerifyRequest *PostProfilePhoneNumberVerifyRequest
}

// Enter a phone verification code for confirmation.
func (r ApiPostProfilePhoneNumberVerifyRequest) PostProfilePhoneNumberVerifyRequest(postProfilePhoneNumberVerifyRequest PostProfilePhoneNumberVerifyRequest) ApiPostProfilePhoneNumberVerifyRequest {
	r.postProfilePhoneNumberVerifyRequest = &postProfilePhoneNumberVerifyRequest
	return r
}

func (r ApiPostProfilePhoneNumberVerifyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostProfilePhoneNumberVerifyExecute(r)
}

/*
PostProfilePhoneNumberVerify Verify a phone number

Verify a phone number by confirming the one-time code received via SMS message after running the [Send a phone number verification code](https://techdocs.akamai.com/linode-api/reference/post-profile-phone-number) operation.

- Verification codes are valid for 10 minutes after they are sent.

- Only the same User that made the verification code request can use that code with this operation.

Once completed, the verified phone number is assigned to the User making the request. To change the verified phone number for a User, first run the [Delete a phone number](https://techdocs.akamai.com/linode-api/reference/delete-profile-phone-number) operation, then begin the verification process again with the [Send a phone number verification code](https://techdocs.akamai.com/linode-api/reference/post-profile-phone-number) operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli phone verify \
  --otp_code 123456
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostProfilePhoneNumberVerifyRequest
*/
func (a *ProfileAPIService) PostProfilePhoneNumberVerify(ctx context.Context, apiVersion string) ApiPostProfilePhoneNumberVerifyRequest {
	return ApiPostProfilePhoneNumberVerifyRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) PostProfilePhoneNumberVerifyExecute(r ApiPostProfilePhoneNumberVerifyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostProfilePhoneNumberVerify")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/phone-number/verify"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postProfilePhoneNumberVerifyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSecurityQuestionsRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	postSecurityQuestionsRequest *PostSecurityQuestionsRequest
}

// Answer Security Questions.
func (r ApiPostSecurityQuestionsRequest) PostSecurityQuestionsRequest(postSecurityQuestionsRequest PostSecurityQuestionsRequest) ApiPostSecurityQuestionsRequest {
	r.postSecurityQuestionsRequest = &postSecurityQuestionsRequest
	return r
}

func (r ApiPostSecurityQuestionsRequest) Execute() (*PostSecurityQuestionsRequest, *http.Response, error) {
	return r.ApiService.PostSecurityQuestionsExecute(r)
}

/*
PostSecurityQuestions Answer security questions

Adds security question responses for your User.

Requires exactly three unique questions.

Previous responses are overwritten if answered or reset to `null` if unanswered.

__Note__. Security questions must be answered for your User prior to accessing the [Create a two factor secret](https://techdocs.akamai.com/linode-api/reference/post-tfa-enable) operation.


<<LB>>

---


- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostSecurityQuestionsRequest
*/
func (a *ProfileAPIService) PostSecurityQuestions(ctx context.Context, apiVersion string) ApiPostSecurityQuestionsRequest {
	return ApiPostSecurityQuestionsRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return PostSecurityQuestionsRequest
func (a *ProfileAPIService) PostSecurityQuestionsExecute(r ApiPostSecurityQuestionsRequest) (*PostSecurityQuestionsRequest, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostSecurityQuestionsRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostSecurityQuestions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/security-questions"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postSecurityQuestionsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTfaConfirmRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	postTfaConfirmRequest *PostTfaConfirmRequest
}

// The Two Factor code you generated with your Two Factor secret.
func (r ApiPostTfaConfirmRequest) PostTfaConfirmRequest(postTfaConfirmRequest PostTfaConfirmRequest) ApiPostTfaConfirmRequest {
	r.postTfaConfirmRequest = &postTfaConfirmRequest
	return r
}

func (r ApiPostTfaConfirmRequest) Execute() (*PostTfaConfirm200Response, *http.Response, error) {
	return r.ApiService.PostTfaConfirmExecute(r)
}

/*
PostTfaConfirm Enable two factor authentication

Confirms that you can successfully generate Two Factor codes and enables TFA on your Account. Once this is complete, login attempts from untrusted computers will be required to provide a Two Factor code before they are successful.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile tfa-confirm \
  --tfa_code 213456
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostTfaConfirmRequest
*/
func (a *ProfileAPIService) PostTfaConfirm(ctx context.Context, apiVersion string) ApiPostTfaConfirmRequest {
	return ApiPostTfaConfirmRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return PostTfaConfirm200Response
func (a *ProfileAPIService) PostTfaConfirmExecute(r ApiPostTfaConfirmRequest) (*PostTfaConfirm200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostTfaConfirm200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostTfaConfirm")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/tfa-enable-confirm"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postTfaConfirmRequest == nil {
		return localVarReturnValue, nil, reportError("postTfaConfirmRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postTfaConfirmRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTfaDisableRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiPostTfaDisableRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PostTfaDisableExecute(r)
}

/*
PostTfaDisable Disable two factor authentication

Disables Two Factor Authentication for your User. Once successful, login attempts from untrusted computers will only require a password before being successful. This is less secure, and is discouraged.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile tfa-disable
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostTfaDisableRequest
*/
func (a *ProfileAPIService) PostTfaDisable(ctx context.Context, apiVersion string) ApiPostTfaDisableRequest {
	return ApiPostTfaDisableRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) PostTfaDisableExecute(r ApiPostTfaDisableRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostTfaDisable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/tfa-disable"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostTfaEnableRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
}

func (r ApiPostTfaEnableRequest) Execute() (*PostTfaEnable200Response, *http.Response, error) {
	return r.ApiService.PostTfaEnableExecute(r)
}

/*
PostTfaEnable Create a two factor secret

Generates a Two Factor secret for your User. To enable TFA for your User, enter the secret obtained from this operation with the [Enable two factor authentication](https://techdocs.akamai.com/linode-api/reference/post-tfa-confirm) operation. Once enabled, logins from untrusted computers are required to provide a TFA code before they are successful.

Run the [Answer security questions](https://techdocs.akamai.com/linode-api/reference/post-security-questions) operation.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile tfa-enable
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPostTfaEnableRequest
*/
func (a *ProfileAPIService) PostTfaEnable(ctx context.Context, apiVersion string) ApiPostTfaEnableRequest {
	return ApiPostTfaEnableRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return PostTfaEnable200Response
func (a *ProfileAPIService) PostTfaEnableExecute(r ApiPostTfaEnableRequest) (*PostTfaEnable200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PostTfaEnable200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PostTfaEnable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/tfa-enable"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutPersonalAccessTokenRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	tokenId int32
	getPersonalAccessTokens200ResponseDataInner *GetPersonalAccessTokens200ResponseDataInner
}

// The fields to update.
func (r ApiPutPersonalAccessTokenRequest) GetPersonalAccessTokens200ResponseDataInner(getPersonalAccessTokens200ResponseDataInner GetPersonalAccessTokens200ResponseDataInner) ApiPutPersonalAccessTokenRequest {
	r.getPersonalAccessTokens200ResponseDataInner = &getPersonalAccessTokens200ResponseDataInner
	return r
}

func (r ApiPutPersonalAccessTokenRequest) Execute() (*GetPersonalAccessTokens200ResponseDataInner, *http.Response, error) {
	return r.ApiService.PutPersonalAccessTokenExecute(r)
}

/*
PutPersonalAccessToken Update a personal access token

Updates a Personal Access Token.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile token-update 123 \
  --label linode-cli
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param tokenId The ID of the token to access.
 @return ApiPutPersonalAccessTokenRequest
*/
func (a *ProfileAPIService) PutPersonalAccessToken(ctx context.Context, apiVersion string, tokenId int32) ApiPutPersonalAccessTokenRequest {
	return ApiPutPersonalAccessTokenRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		tokenId: tokenId,
	}
}

// Execute executes the request
//  @return GetPersonalAccessTokens200ResponseDataInner
func (a *ProfileAPIService) PutPersonalAccessTokenExecute(r ApiPutPersonalAccessTokenRequest) (*GetPersonalAccessTokens200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetPersonalAccessTokens200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PutPersonalAccessToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/tokens/{tokenId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tokenId"+"}", url.PathEscape(parameterValueToString(r.tokenId, "tokenId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getPersonalAccessTokens200ResponseDataInner == nil {
		return localVarReturnValue, nil, reportError("getPersonalAccessTokens200ResponseDataInner is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getPersonalAccessTokens200ResponseDataInner
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutProfileRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	getProfile200Response *GetProfile200Response
}

// The fields to update.
func (r ApiPutProfileRequest) GetProfile200Response(getProfile200Response GetProfile200Response) ApiPutProfileRequest {
	r.getProfile200Response = &getProfile200Response
	return r
}

func (r ApiPutProfileRequest) Execute() (*GetProfile200Response, *http.Response, error) {
	return r.ApiService.PutProfileExecute(r)
}

/*
PutProfile Update a profile

Update information in your Profile.  This operation requires the `account:read_write` OAuth Scope.

__Parent and child accounts__

In a [parent and child account](https://www.linode.com/docs/guides/parent-child-accounts/) environment, the following apply:

- You can't edit the `email` for a child account parent user (proxy user). This value is fixed and set when you provision this environment.


<<LB>>

---


- __CLI__.

    ```
    linode-cli profile update \
  --email example-user@gmail.com \
  --timezone US/Eastern \
  --email_notifications true \
  --list_auth_method keys_only \
  --two_factor_auth true \
  --restricted false
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPutProfileRequest
*/
func (a *ProfileAPIService) PutProfile(ctx context.Context, apiVersion string) ApiPutProfileRequest {
	return ApiPutProfileRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return GetProfile200Response
func (a *ProfileAPIService) PutProfileExecute(r ApiPutProfileRequest) (*GetProfile200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetProfile200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PutProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getProfile200Response == nil {
		return localVarReturnValue, nil, reportError("getProfile200Response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getProfile200Response
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutSshKeyRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	sshKeyId int32
	putSshKeyRequest *PutSshKeyRequest
}

// The fields to update.
func (r ApiPutSshKeyRequest) PutSshKeyRequest(putSshKeyRequest PutSshKeyRequest) ApiPutSshKeyRequest {
	r.putSshKeyRequest = &putSshKeyRequest
	return r
}

func (r ApiPutSshKeyRequest) Execute() (*GetSshKeys200ResponseDataInner, *http.Response, error) {
	return r.ApiService.PutSshKeyExecute(r)
}

/*
PutSshKey Update an SSH key

Updates an SSH Key that you have permission to `read_write`.

Only SSH key labels can be updated.


<<LB>>

---


- __CLI__.

    ```
    linode-cli sshkeys update 42 \
  --label "my laptop"
    ```

    [Learn more...](https://www.linode.com/docs/products/tools/cli/get-started/)

- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @param sshKeyId The ID of the SSHKey.
 @return ApiPutSshKeyRequest
*/
func (a *ProfileAPIService) PutSshKey(ctx context.Context, apiVersion string, sshKeyId int32) ApiPutSshKeyRequest {
	return ApiPutSshKeyRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
		sshKeyId: sshKeyId,
	}
}

// Execute executes the request
//  @return GetSshKeys200ResponseDataInner
func (a *ProfileAPIService) PutSshKeyExecute(r ApiPutSshKeyRequest) (*GetSshKeys200ResponseDataInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSshKeys200ResponseDataInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PutSshKey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/sshkeys/{sshKeyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sshKeyId"+"}", url.PathEscape(parameterValueToString(r.sshKeyId, "sshKeyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.putSshKeyRequest == nil {
		return localVarReturnValue, nil, reportError("putSshKeyRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putSshKeyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUserPreferencesRequest struct {
	ctx context.Context
	ApiService *ProfileAPIService
	apiVersion string
	body *map[string]interface{}
}

// The user preferences to update or store.
func (r ApiPutUserPreferencesRequest) Body(body map[string]interface{}) ApiPutUserPreferencesRequest {
	r.body = &body
	return r
}

func (r ApiPutUserPreferencesRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.PutUserPreferencesExecute(r)
}

/*
PutUserPreferences Update a user's preferences

Updates a user's preferences. These preferences are tied to the OAuth client that generated the token making the request. The user preferences endpoints allow consumers of the API to store arbitrary JSON data, such as a user's font size preference or preferred display name. An account may have multiple preferences. Preferences, and the pertaining request body, may contain any arbitrary JSON data that the user would like to store.


<<LB>>

---


- __OAuth scopes__.

    ```
    account:read_write
    ```

    [Learn more...](https://techdocs.akamai.com/linode-api/reference/get-started#oauth)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiVersion __Enum__ Call either the `v4` URL, or `v4beta` for operations still in Beta.
 @return ApiPutUserPreferencesRequest
*/
func (a *ProfileAPIService) PutUserPreferences(ctx context.Context, apiVersion string) ApiPutUserPreferencesRequest {
	return ApiPutUserPreferencesRequest{
		ApiService: a,
		ctx: ctx,
		apiVersion: apiVersion,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProfileAPIService) PutUserPreferencesExecute(r ApiPutUserPreferencesRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProfileAPIService.PutUserPreferences")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{apiVersion}/profile/preferences"
	localVarPath = strings.Replace(localVarPath, "{"+"apiVersion"+"}", url.PathEscape(parameterValueToString(r.apiVersion, "apiVersion")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GetAccountDefaultResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
